{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VerusIDSignature = exports.Utf8OrBase58Object = exports.HexDataVdxfObject = exports.Utf8DataVdxfObject = exports.BufferDataVdxfObject = exports.VDXFObject = void 0;\nconst base64url_1 = require(\"base64url\");\nconst createHash = require(\"create-hash\");\nconst vdxf_1 = require(\"../constants/vdxf\");\nconst address_1 = require(\"../utils/address\");\nconst bufferutils_1 = require(\"../utils/bufferutils\");\nconst varint_1 = require(\"../utils/varint\");\nconst varuint_1 = require(\"../utils/varuint\");\nconst Hash160_1 = require(\"./classes/Hash160\");\nconst keys_1 = require(\"./keys\");\nconst bn_js_1 = require(\"bn.js\");\n__exportStar(require(\"./keys\"), exports);\n__exportStar(require(\"./scopes\"), exports);\nclass VDXFObject {\n  constructor() {\n    let key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let serializekey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this.serializekey = true;\n    this.vdxfkey = key;\n    this.version = vdxf_1.VDXF_OBJECT_DEFAULT_VERSION;\n    this.serializekey = serializekey;\n  }\n  getVersionNoFlags() {\n    return this.version;\n  }\n  toJson() {\n    return {};\n  }\n  toString() {\n    let includeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.serializekey;\n    return base64url_1.default.encode(this.toBuffer(includeKey));\n  }\n  dataByteLength() {\n    return 0;\n  }\n  toDataBuffer() {\n    return Buffer.alloc(0);\n  }\n  fromDataBuffer(buffer) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return offset;\n  }\n  isValidVersion() {\n    return true;\n  }\n  fromBuffer(buffer) {\n    let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let vdxfkey = arguments.length > 2 ? arguments[2] : undefined;\n    const reader = new bufferutils_1.default.BufferReader(buffer, offset);\n    if (vdxfkey == null) {\n      const keyHash = reader.readSlice(vdxf_1.HASH160_BYTE_LENGTH);\n      this.vdxfkey = (0, address_1.toBase58Check)(keyHash, vdxf_1.I_ADDR_VERSION);\n    }\n    const version = reader.readVarInt();\n    this.version = version;\n    if (!this.isValidVersion()) throw new Error(\"Unsupported version for vdxf object.\");\n    if (offset < buffer.length - 1) {\n      reader.offset = this.fromDataBuffer(reader.buffer, reader.offset);\n    }\n    return reader.offset;\n  }\n  byteLength() {\n    let includeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.serializekey;\n    const dataLength = this.dataByteLength();\n    const keyLength = includeKey ? (0, address_1.fromBase58Check)(this.vdxfkey).hash.length : 0;\n    const versionEncodingLength = varint_1.default.encodingLength(new bn_js_1.BN(this.version));\n    const dataEncodingLength = varuint_1.default.encodingLength(dataLength);\n    return dataLength + keyLength + versionEncodingLength + dataEncodingLength;\n  }\n  toBuffer() {\n    let includeKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.serializekey;\n    const key = (0, address_1.fromBase58Check)(this.vdxfkey);\n    const dataLength = this.dataByteLength();\n    const buffer = Buffer.alloc(this.byteLength(includeKey));\n    const writer = new bufferutils_1.default.BufferWriter(buffer);\n    if (includeKey) {\n      writer.writeSlice(key.hash);\n    }\n    writer.writeVarInt(new bn_js_1.BN(this.version, 10));\n    if (dataLength) {\n      writer.writeVarSlice(this.toDataBuffer());\n    }\n    return writer.buffer;\n  }\n  toSha256() {\n    return createHash(\"sha256\").update(this.toBuffer()).digest();\n  }\n}\nexports.VDXFObject = VDXFObject;\nclass BufferDataVdxfObject extends VDXFObject {\n  constructor() {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let vdxfkey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"hex\";\n    super(vdxfkey);\n    this.encoding = \"hex\";\n    this.data = data;\n    this.encoding = encoding;\n  }\n  dataByteLength() {\n    return this.toDataBuffer().length;\n  }\n  toDataBuffer() {\n    return Buffer.from(this.data, this.encoding);\n  }\n  fromDataBuffer(buffer, offset) {\n    const reader = new bufferutils_1.default.BufferReader(buffer, offset);\n    this.data = reader.readVarSlice().toString(this.encoding);\n    return reader.offset;\n  }\n  toJson() {\n    return {\n      data: this.data,\n      vdxfkey: this.vdxfkey\n    };\n  }\n}\nexports.BufferDataVdxfObject = BufferDataVdxfObject;\nclass Utf8DataVdxfObject extends BufferDataVdxfObject {\n  constructor() {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let vdxfkey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    super(data, vdxfkey, \"utf-8\");\n  }\n}\nexports.Utf8DataVdxfObject = Utf8DataVdxfObject;\nclass HexDataVdxfObject extends BufferDataVdxfObject {\n  constructor() {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let vdxfkey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    super(data, vdxfkey, \"hex\");\n  }\n}\nexports.HexDataVdxfObject = HexDataVdxfObject;\nclass Utf8OrBase58Object extends VDXFObject {\n  constructor() {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    let vdxfkey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    let base58Keys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    super(vdxfkey);\n    // VDXF keys that would cause this object to be base58 instead of utf8\n    this.base58Keys = {};\n    for (const key of base58Keys) {\n      this.base58Keys[key] = true;\n    }\n    this.data = data;\n  }\n  isBase58() {\n    return this.base58Keys[this.vdxfkey];\n  }\n  dataByteLength() {\n    return this.toDataBuffer().length;\n  }\n  toDataBuffer() {\n    return this.isBase58() ? Hash160_1.Hash160.fromAddress(this.data, false).toBuffer() : Buffer.from(this.data, \"utf-8\");\n  }\n  fromDataBuffer(buffer, offset) {\n    const reader = new bufferutils_1.default.BufferReader(buffer, offset);\n    if (this.isBase58()) {\n      const _data = new Hash160_1.Hash160();\n      // varlength is set to true here because vdxf objects always have a \n      // variable length data field. This has160 object was not creted with\n      // varlength true, but this is a shortcut instead of writing readVarSlice \n      // and then fromBuffer. \n      reader.offset = _data.fromBuffer(reader.buffer, true, reader.offset);\n      _data.varlength = false;\n      this.data = _data.toAddress();\n    } else {\n      this.data = reader.readVarSlice().toString('utf-8');\n    }\n    return reader.offset;\n  }\n  toJson() {\n    return {\n      data: this.data,\n      vdxfkey: this.vdxfkey\n    };\n  }\n}\nexports.Utf8OrBase58Object = Utf8OrBase58Object;\nclass VerusIDSignature extends VDXFObject {\n  constructor() {\n    let sig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      signature: \"\"\n    };\n    let vdxfkey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : keys_1.IDENTITY_AUTH_SIG_VDXF_KEY;\n    let serializekey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    super(vdxfkey.vdxfid, serializekey);\n    this.signature = sig.signature;\n  }\n  dataByteLength() {\n    return this.toDataBuffer().length;\n  }\n  toDataBuffer() {\n    return Buffer.from(this.signature, \"base64\");\n  }\n  fromDataBuffer(buffer, offset) {\n    const reader = new bufferutils_1.default.BufferReader(buffer, offset);\n    this.signature = reader.readVarSlice().toString(\"base64\");\n    return reader.offset;\n  }\n  static fromJson(data) {\n    return new VerusIDSignature({\n      signature: data.signature\n    }, keys_1.IDENTITY_AUTH_SIG_VDXF_KEY, data.serializekey);\n  }\n  toJson() {\n    return {\n      vdxfkey: this.vdxfkey,\n      signature: this.signature,\n      serializekey: this.serializekey\n    };\n  }\n}\nexports.VerusIDSignature = VerusIDSignature;","map":{"version":3,"names":["__createBinding","Object","create","o","m","k","k2","undefined","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__exportStar","exports","p","prototype","hasOwnProperty","call","value","VerusIDSignature","Utf8OrBase58Object","HexDataVdxfObject","Utf8DataVdxfObject","BufferDataVdxfObject","VDXFObject","base64url_1","require","createHash","vdxf_1","address_1","bufferutils_1","varint_1","varuint_1","Hash160_1","keys_1","bn_js_1","constructor","key","arguments","length","serializekey","vdxfkey","version","VDXF_OBJECT_DEFAULT_VERSION","getVersionNoFlags","toJson","toString","includeKey","default","encode","toBuffer","dataByteLength","toDataBuffer","Buffer","alloc","fromDataBuffer","buffer","offset","isValidVersion","fromBuffer","reader","BufferReader","keyHash","readSlice","HASH160_BYTE_LENGTH","toBase58Check","I_ADDR_VERSION","readVarInt","Error","byteLength","dataLength","keyLength","fromBase58Check","hash","versionEncodingLength","encodingLength","BN","dataEncodingLength","writer","BufferWriter","writeSlice","writeVarInt","writeVarSlice","toSha256","update","digest","data","encoding","from","readVarSlice","base58Keys","isBase58","Hash160","fromAddress","_data","varlength","toAddress","sig","signature","IDENTITY_AUTH_SIG_VDXF_KEY","vdxfid","fromJson"],"sources":["/Users/oddfl3x/Code/varB/vARRRBridgeWebsite-main/node_modules/verus-typescript-primitives/dist/vdxf/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VerusIDSignature = exports.Utf8OrBase58Object = exports.HexDataVdxfObject = exports.Utf8DataVdxfObject = exports.BufferDataVdxfObject = exports.VDXFObject = void 0;\nconst base64url_1 = require(\"base64url\");\nconst createHash = require(\"create-hash\");\nconst vdxf_1 = require(\"../constants/vdxf\");\nconst address_1 = require(\"../utils/address\");\nconst bufferutils_1 = require(\"../utils/bufferutils\");\nconst varint_1 = require(\"../utils/varint\");\nconst varuint_1 = require(\"../utils/varuint\");\nconst Hash160_1 = require(\"./classes/Hash160\");\nconst keys_1 = require(\"./keys\");\nconst bn_js_1 = require(\"bn.js\");\n__exportStar(require(\"./keys\"), exports);\n__exportStar(require(\"./scopes\"), exports);\nclass VDXFObject {\n    constructor(key = \"\", serializekey = true) {\n        this.serializekey = true;\n        this.vdxfkey = key;\n        this.version = vdxf_1.VDXF_OBJECT_DEFAULT_VERSION;\n        this.serializekey = serializekey;\n    }\n    getVersionNoFlags() {\n        return this.version;\n    }\n    toJson() {\n        return {};\n    }\n    toString(includeKey = this.serializekey) {\n        return base64url_1.default.encode(this.toBuffer(includeKey));\n    }\n    dataByteLength() {\n        return 0;\n    }\n    toDataBuffer() {\n        return Buffer.alloc(0);\n    }\n    fromDataBuffer(buffer, offset = 0) {\n        return offset;\n    }\n    isValidVersion() {\n        return true;\n    }\n    fromBuffer(buffer, offset = 0, vdxfkey) {\n        const reader = new bufferutils_1.default.BufferReader(buffer, offset);\n        if (vdxfkey == null) {\n            const keyHash = reader.readSlice(vdxf_1.HASH160_BYTE_LENGTH);\n            this.vdxfkey = (0, address_1.toBase58Check)(keyHash, vdxf_1.I_ADDR_VERSION);\n        }\n        const version = reader.readVarInt();\n        this.version = version;\n        if (!this.isValidVersion())\n            throw new Error(\"Unsupported version for vdxf object.\");\n        if (offset < buffer.length - 1) {\n            reader.offset = this.fromDataBuffer(reader.buffer, reader.offset);\n        }\n        return reader.offset;\n    }\n    byteLength(includeKey = this.serializekey) {\n        const dataLength = this.dataByteLength();\n        const keyLength = includeKey ? (0, address_1.fromBase58Check)(this.vdxfkey).hash.length : 0;\n        const versionEncodingLength = varint_1.default.encodingLength(new bn_js_1.BN(this.version));\n        const dataEncodingLength = varuint_1.default.encodingLength(dataLength);\n        return dataLength + keyLength + versionEncodingLength + dataEncodingLength;\n    }\n    toBuffer(includeKey = this.serializekey) {\n        const key = (0, address_1.fromBase58Check)(this.vdxfkey);\n        const dataLength = this.dataByteLength();\n        const buffer = Buffer.alloc(this.byteLength(includeKey));\n        const writer = new bufferutils_1.default.BufferWriter(buffer);\n        if (includeKey) {\n            writer.writeSlice(key.hash);\n        }\n        writer.writeVarInt(new bn_js_1.BN(this.version, 10));\n        if (dataLength) {\n            writer.writeVarSlice(this.toDataBuffer());\n        }\n        return writer.buffer;\n    }\n    toSha256() {\n        return createHash(\"sha256\").update(this.toBuffer()).digest();\n    }\n}\nexports.VDXFObject = VDXFObject;\nclass BufferDataVdxfObject extends VDXFObject {\n    constructor(data = \"\", vdxfkey = \"\", encoding = \"hex\") {\n        super(vdxfkey);\n        this.encoding = \"hex\";\n        this.data = data;\n        this.encoding = encoding;\n    }\n    dataByteLength() {\n        return this.toDataBuffer().length;\n    }\n    toDataBuffer() {\n        return Buffer.from(this.data, this.encoding);\n    }\n    fromDataBuffer(buffer, offset) {\n        const reader = new bufferutils_1.default.BufferReader(buffer, offset);\n        this.data = reader.readVarSlice().toString(this.encoding);\n        return reader.offset;\n    }\n    toJson() {\n        return {\n            data: this.data,\n            vdxfkey: this.vdxfkey,\n        };\n    }\n}\nexports.BufferDataVdxfObject = BufferDataVdxfObject;\nclass Utf8DataVdxfObject extends BufferDataVdxfObject {\n    constructor(data = \"\", vdxfkey = \"\") {\n        super(data, vdxfkey, \"utf-8\");\n    }\n}\nexports.Utf8DataVdxfObject = Utf8DataVdxfObject;\nclass HexDataVdxfObject extends BufferDataVdxfObject {\n    constructor(data = \"\", vdxfkey = \"\") {\n        super(data, vdxfkey, \"hex\");\n    }\n}\nexports.HexDataVdxfObject = HexDataVdxfObject;\nclass Utf8OrBase58Object extends VDXFObject {\n    constructor(data = \"\", vdxfkey = \"\", base58Keys = []) {\n        super(vdxfkey);\n        // VDXF keys that would cause this object to be base58 instead of utf8\n        this.base58Keys = {};\n        for (const key of base58Keys) {\n            this.base58Keys[key] = true;\n        }\n        this.data = data;\n    }\n    isBase58() {\n        return this.base58Keys[this.vdxfkey];\n    }\n    dataByteLength() {\n        return this.toDataBuffer().length;\n    }\n    toDataBuffer() {\n        return this.isBase58()\n            ? (Hash160_1.Hash160.fromAddress(this.data, false)).toBuffer()\n            : Buffer.from(this.data, \"utf-8\");\n    }\n    fromDataBuffer(buffer, offset) {\n        const reader = new bufferutils_1.default.BufferReader(buffer, offset);\n        if (this.isBase58()) {\n            const _data = new Hash160_1.Hash160();\n            // varlength is set to true here because vdxf objects always have a \n            // variable length data field. This has160 object was not creted with\n            // varlength true, but this is a shortcut instead of writing readVarSlice \n            // and then fromBuffer. \n            reader.offset = _data.fromBuffer(reader.buffer, true, reader.offset);\n            _data.varlength = false;\n            this.data = _data.toAddress();\n        }\n        else {\n            this.data = reader.readVarSlice().toString('utf-8');\n        }\n        return reader.offset;\n    }\n    toJson() {\n        return {\n            data: this.data,\n            vdxfkey: this.vdxfkey,\n        };\n    }\n}\nexports.Utf8OrBase58Object = Utf8OrBase58Object;\nclass VerusIDSignature extends VDXFObject {\n    constructor(sig = { signature: \"\" }, vdxfkey = keys_1.IDENTITY_AUTH_SIG_VDXF_KEY, serializekey = true) {\n        super(vdxfkey.vdxfid, serializekey);\n        this.signature = sig.signature;\n    }\n    dataByteLength() {\n        return this.toDataBuffer().length;\n    }\n    toDataBuffer() {\n        return Buffer.from(this.signature, \"base64\");\n    }\n    fromDataBuffer(buffer, offset) {\n        const reader = new bufferutils_1.default.BufferReader(buffer, offset);\n        this.signature = reader.readVarSlice().toString(\"base64\");\n        return reader.offset;\n    }\n    static fromJson(data) {\n        return new VerusIDSignature({ signature: data.signature }, keys_1.IDENTITY_AUTH_SIG_VDXF_KEY, data.serializekey);\n    }\n    toJson() {\n        return {\n            vdxfkey: this.vdxfkey,\n            signature: this.signature,\n            serializekey: this.serializekey\n        };\n    }\n}\nexports.VerusIDSignature = VerusIDSignature;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}