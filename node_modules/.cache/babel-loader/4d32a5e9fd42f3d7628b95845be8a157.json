{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;\nfunction number(n) {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error(\"positive integer expected, not \".concat(n));\n}\nexports.number = number;\nfunction bool(b) {\n  if (typeof b !== 'boolean') throw new Error(\"boolean expected, not \".concat(b));\n}\nexports.bool = bool;\n// copied from utils\nfunction isBytes(a) {\n  return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';\n}\nexports.isBytes = isBytes;\nfunction bytes(b) {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    lengths[_key - 1] = arguments[_key];\n  }\n  if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error(\"Uint8Array expected of length \".concat(lengths, \", not of length=\").concat(b.length));\n}\nexports.bytes = bytes;\nfunction hash(h) {\n  if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  number(h.outputLen);\n  number(h.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance) {\n  let checkFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(\"digestInto() expects output buffer of length at least \".concat(min));\n  }\n}\nexports.output = output;\nconst assert = {\n  number,\n  bool,\n  bytes,\n  hash,\n  exists,\n  output\n};\nexports.default = assert;","map":{"version":3,"sources":["src/_assert.ts"],"names":[],"mappings":";;;;;;AAAA,SAAS,MAAM,CAAC,CAAS,EAAA;EACvB,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,mCAAA,MAAA,CAAmC,CAAC,CAAE,CAAC;AAC/F;AA6CS,OAAA,CAAA,MAAA,GAAA,MAAA;AA3CT,SAAS,IAAI,CAAC,CAAU,EAAA;EACtB,IAAI,OAAO,CAAC,KAAK,SAAS,EAAE,MAAM,IAAI,KAAK,0BAAA,MAAA,CAA0B,CAAC,CAAE,CAAC;AAC3E;AAyCiB,OAAA,CAAA,IAAA,GAAA,IAAA;AAvCjB;AACA,SAAgB,OAAO,CAAC,CAAU,EAAA;EAChC,OACE,CAAC,YAAY,UAAU,IACtB,CAAC,IAAI,IAAI,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,YAAa;AAE/E;AALA,OAAA,CAAA,OAAA,GAAA,OAAA;AAOA,SAAS,KAAK,CAAC,CAAyB,EAAsB;EAC5D,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC;EAAC,SAAA,IAAA,GAAA,SAAA,CAAA,MAAA,EADb,OAAiB,OAAA,KAAA,CAAA,IAAA,OAAA,IAAA,WAAA,IAAA,MAAA,IAAA,GAAA,IAAA,EAAA,IAAA;IAAjB,OAAiB,CAAA,IAAA,QAAA,SAAA,CAAA,IAAA;EAAA;EAE5D,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC,CAAC,MAAM,CAAC,EACnD,MAAM,IAAI,KAAK,kCAAA,MAAA,CAAkC,OAAO,sBAAA,MAAA,CAAmB,CAAC,CAAC,MAAM,CAAE,CAAC;AAC1F;AA2BuB,OAAA,CAAA,KAAA,GAAA,KAAA;AAnBvB,SAAS,IAAI,CAAC,CAAO,EAAA;EACnB,IAAI,OAAO,CAAC,KAAK,UAAU,IAAI,OAAO,CAAC,CAAC,MAAM,KAAK,UAAU,EAC3D,MAAM,IAAI,KAAK,CAAC,iDAAiD,CAAC;EACpE,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC;EACnB,MAAM,CAAC,CAAC,CAAC,QAAQ,CAAC;AACpB;AAc8B,OAAA,CAAA,IAAA,GAAA,IAAA;AAZ9B,SAAS,MAAM,CAAC,QAAa,EAAsB;EAAA,IAApB,aAAa,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAG,IAAI;EACjD,IAAI,QAAQ,CAAC,SAAS,EAAE,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC;EAC3E,IAAI,aAAa,IAAI,QAAQ,CAAC,QAAQ,EAAE,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC;AAClG;AASoC,OAAA,CAAA,MAAA,GAAA,MAAA;AARpC,SAAS,MAAM,CAAC,GAAQ,EAAE,QAAa,EAAA;EACrC,KAAK,CAAC,GAAG,CAAC;EACV,MAAM,GAAG,GAAG,QAAQ,CAAC,SAAS;EAC9B,IAAI,GAAG,CAAC,MAAM,GAAG,GAAG,EAAE;IACpB,MAAM,IAAI,KAAK,0DAAA,MAAA,CAA0D,GAAG,CAAE,CAAC;EACjF;AACF;AAE4C,OAAA,CAAA,MAAA,GAAA,MAAA;AAE5C,MAAM,MAAM,GAAG;EAAE,MAAM;EAAE,IAAI;EAAE,KAAK;EAAE,IAAI;EAAE,MAAM;EAAE;AAAM,CAAE;AAC5D,OAAA,CAAA,OAAA,GAAe,MAAM","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nexports.number = number;\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\nexports.bool = bool;\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nexports.isBytes = isBytes;\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nexports.bytes = bytes;\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nexports.hash = hash;\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nexports.exists = exists;\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nexports.output = output;\nconst assert = { number, bool, bytes, hash, exists, output };\nexports.default = assert;\n//# sourceMappingURL=_assert.js.map"]},"metadata":{},"sourceType":"script"}