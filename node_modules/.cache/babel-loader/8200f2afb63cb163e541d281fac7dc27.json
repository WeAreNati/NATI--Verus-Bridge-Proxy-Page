{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Hash160SerEnt = exports.Hash160 = void 0;\nconst vdxf_1 = require(\"../../constants/vdxf\");\nconst address_1 = require(\"../../utils/address\");\nconst bufferutils_1 = require(\"../../utils/bufferutils\");\nconst varuint_1 = require(\"../../utils/varuint\");\nclass Hash160 {\n  constructor() {\n    let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Buffer.alloc(20);\n    let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vdxf_1.I_ADDR_VERSION;\n    let varlength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.hash = hash;\n    this.version = version;\n    this.varlength = varlength;\n  }\n  static getEmpty() {\n    return new Hash160(Buffer.alloc(0), 0, true);\n  }\n  static fromAddress(address) {\n    let varlength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const base58 = (0, address_1.fromBase58Check)(address);\n    return new Hash160(base58.hash, base58.version, varlength);\n  }\n  toAddress() {\n    if (this.hash.length == 0) {\n      return null;\n    } else return (0, address_1.toBase58Check)(this.hash, this.version);\n  }\n  /**\n   * @deprecated The method has been replaced by getByteLength and will be removed in the future\n   */\n  byteLength() {\n    return this.getByteLength();\n  }\n  getByteLength() {\n    let length = 0;\n    if (this.varlength) {\n      length += varuint_1.default.encodingLength(this.hash.length);\n      length += this.hash.length;\n    } else {\n      length += this.hash.length;\n    }\n    return length;\n  }\n  toBuffer() {\n    const buffer = Buffer.alloc(this.getByteLength());\n    const writer = new bufferutils_1.default.BufferWriter(buffer);\n    if (this.varlength) {\n      writer.writeVarSlice(this.hash);\n    } else {\n      writer.writeSlice(this.hash);\n    }\n    return writer.buffer;\n  }\n  fromBuffer(buffer) {\n    let varlength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const reader = new bufferutils_1.default.BufferReader(buffer, offset);\n    if (varlength) {\n      this.hash = reader.readVarSlice();\n    } else {\n      this.hash = reader.readSlice(vdxf_1.HASH160_BYTE_LENGTH);\n    }\n    this.version = vdxf_1.I_ADDR_VERSION;\n    this.varlength = varlength;\n    return reader.offset;\n  }\n  toJson() {\n    return {\n      hash: this.hash,\n      version: this.version\n    };\n  }\n}\nexports.Hash160 = Hash160;\nclass Hash160SerEnt extends Hash160 {\n  constructor() {\n    let hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Buffer.alloc(20);\n    let version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vdxf_1.I_ADDR_VERSION;\n    let varlength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    super(hash, version, varlength);\n  }\n  fromBuffer(buffer, offset, varlength) {\n    return super.fromBuffer(buffer, varlength, offset);\n  }\n}\nexports.Hash160SerEnt = Hash160SerEnt;","map":{"version":3,"names":["Object","defineProperty","exports","value","Hash160SerEnt","Hash160","vdxf_1","require","address_1","bufferutils_1","varuint_1","constructor","hash","arguments","length","undefined","Buffer","alloc","version","I_ADDR_VERSION","varlength","getEmpty","fromAddress","address","base58","fromBase58Check","toAddress","toBase58Check","byteLength","getByteLength","default","encodingLength","toBuffer","buffer","writer","BufferWriter","writeVarSlice","writeSlice","fromBuffer","offset","reader","BufferReader","readVarSlice","readSlice","HASH160_BYTE_LENGTH","toJson"],"sources":["/Users/oddfl3x/Code/varB/vARRRBridgeWebsite-main/node_modules/verus-typescript-primitives/dist/vdxf/classes/Hash160.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Hash160SerEnt = exports.Hash160 = void 0;\nconst vdxf_1 = require(\"../../constants/vdxf\");\nconst address_1 = require(\"../../utils/address\");\nconst bufferutils_1 = require(\"../../utils/bufferutils\");\nconst varuint_1 = require(\"../../utils/varuint\");\nclass Hash160 {\n    constructor(hash = Buffer.alloc(20), version = vdxf_1.I_ADDR_VERSION, varlength = false) {\n        this.hash = hash;\n        this.version = version;\n        this.varlength = varlength;\n    }\n    static getEmpty() {\n        return new Hash160(Buffer.alloc(0), 0, true);\n    }\n    static fromAddress(address, varlength = false) {\n        const base58 = (0, address_1.fromBase58Check)(address);\n        return new Hash160(base58.hash, base58.version, varlength);\n    }\n    toAddress() {\n        if (this.hash.length == 0) {\n            return null;\n        }\n        else\n            return (0, address_1.toBase58Check)(this.hash, this.version);\n    }\n    /**\n     * @deprecated The method has been replaced by getByteLength and will be removed in the future\n     */\n    byteLength() {\n        return this.getByteLength();\n    }\n    getByteLength() {\n        let length = 0;\n        if (this.varlength) {\n            length += varuint_1.default.encodingLength(this.hash.length);\n            length += this.hash.length;\n        }\n        else {\n            length += this.hash.length;\n        }\n        return length;\n    }\n    toBuffer() {\n        const buffer = Buffer.alloc(this.getByteLength());\n        const writer = new bufferutils_1.default.BufferWriter(buffer);\n        if (this.varlength) {\n            writer.writeVarSlice(this.hash);\n        }\n        else {\n            writer.writeSlice(this.hash);\n        }\n        return writer.buffer;\n    }\n    fromBuffer(buffer, varlength = false, offset = 0) {\n        const reader = new bufferutils_1.default.BufferReader(buffer, offset);\n        if (varlength) {\n            this.hash = reader.readVarSlice();\n        }\n        else {\n            this.hash = reader.readSlice(vdxf_1.HASH160_BYTE_LENGTH);\n        }\n        this.version = vdxf_1.I_ADDR_VERSION;\n        this.varlength = varlength;\n        return reader.offset;\n    }\n    toJson() {\n        return {\n            hash: this.hash,\n            version: this.version,\n        };\n    }\n}\nexports.Hash160 = Hash160;\nclass Hash160SerEnt extends Hash160 {\n    constructor(hash = Buffer.alloc(20), version = vdxf_1.I_ADDR_VERSION, varlength = false) {\n        super(hash, version, varlength);\n    }\n    fromBuffer(buffer, offset, varlength) {\n        return super.fromBuffer(buffer, varlength, offset);\n    }\n}\nexports.Hash160SerEnt = Hash160SerEnt;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}