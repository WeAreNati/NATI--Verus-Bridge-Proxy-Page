{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeSaplingAddress = exports.decodeSaplingAddress = exports.convertBits = exports.toBech32 = exports.fromBech32 = void 0;\nconst bech32_1 = require(\"bech32\");\nconst fromBech32 = address => {\n  var result = bech32_1.bech32.decode(address);\n  var data = bech32_1.bech32.fromWords(result.words);\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data)\n  };\n};\nexports.fromBech32 = fromBech32;\nconst toBech32 = (prefix, data) => {\n  const words = bech32_1.bech32.toWords(data);\n  var result = bech32_1.bech32.encode(prefix, words);\n  return result;\n};\nexports.toBech32 = toBech32;\nconst convertBits = (data, from, to, strictMode) => {\n  const length = strictMode ? Math.floor(data.length * from / to) : Math.ceil(data.length * from / to);\n  const mask = (1 << to) - 1;\n  const result = Buffer.alloc(length);\n  let index = 0;\n  let accumulator = 0;\n  let bits = 0;\n  for (const value of data) {\n    accumulator = accumulator << from | value;\n    bits += from;\n    while (bits >= to) {\n      bits -= to;\n      result[index] = accumulator >> bits & mask;\n      ++index;\n    }\n  }\n  if (!strictMode) {\n    if (bits > 0) {\n      result[index] = accumulator << to - bits & mask;\n      ++index;\n    }\n  } else {\n    throw new Error(\"Bits cannot be converted\");\n  }\n  return result;\n};\nexports.convertBits = convertBits;\nconst decodeSaplingAddress = address => {\n  const result = (0, exports.fromBech32)(address);\n  //const data = convertBits(result.data, 5, 8, false);\n  if (result.data.length !== 43) {\n    throw new Error('Invalid sapling address');\n  }\n  return {\n    d: result.data.subarray(0, 11),\n    pk_d: result.data.subarray(11)\n  };\n};\nexports.decodeSaplingAddress = decodeSaplingAddress;\nconst encodeSaplingAddress = data => {\n  const buffer = Buffer.concat([data.d, data.pk_d]);\n  //const data = convertBits(buffer, 8, 5, false);\n  return (0, exports.toBech32)('zs', buffer);\n};\nexports.encodeSaplingAddress = encodeSaplingAddress;","map":{"version":3,"names":["Object","defineProperty","exports","value","encodeSaplingAddress","decodeSaplingAddress","convertBits","toBech32","fromBech32","bech32_1","require","address","result","bech32","decode","data","fromWords","words","version","prefix","Buffer","from","toWords","encode","to","strictMode","length","Math","floor","ceil","mask","alloc","index","accumulator","bits","Error","d","subarray","pk_d","buffer","concat"],"sources":["/Users/oddfl3x/Code/varB/NATIBridgeWebsite-main/node_modules/verus-typescript-primitives/dist/utils/sapling.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeSaplingAddress = exports.decodeSaplingAddress = exports.convertBits = exports.toBech32 = exports.fromBech32 = void 0;\nconst bech32_1 = require(\"bech32\");\nconst fromBech32 = (address) => {\n    var result = bech32_1.bech32.decode(address);\n    var data = bech32_1.bech32.fromWords(result.words);\n    return {\n        version: result.words[0],\n        prefix: result.prefix,\n        data: Buffer.from(data)\n    };\n};\nexports.fromBech32 = fromBech32;\nconst toBech32 = (prefix, data) => {\n    const words = bech32_1.bech32.toWords(data);\n    var result = bech32_1.bech32.encode(prefix, words);\n    return result;\n};\nexports.toBech32 = toBech32;\nconst convertBits = (data, from, to, strictMode) => {\n    const length = strictMode\n        ? Math.floor((data.length * from) / to)\n        : Math.ceil((data.length * from) / to);\n    const mask = (1 << to) - 1;\n    const result = Buffer.alloc(length);\n    let index = 0;\n    let accumulator = 0;\n    let bits = 0;\n    for (const value of data) {\n        accumulator = (accumulator << from) | value;\n        bits += from;\n        while (bits >= to) {\n            bits -= to;\n            result[index] = (accumulator >> bits) & mask;\n            ++index;\n        }\n    }\n    if (!strictMode) {\n        if (bits > 0) {\n            result[index] = (accumulator << (to - bits)) & mask;\n            ++index;\n        }\n    }\n    else {\n        throw new Error(\"Bits cannot be converted\");\n    }\n    return result;\n};\nexports.convertBits = convertBits;\nconst decodeSaplingAddress = (address) => {\n    const result = (0, exports.fromBech32)(address);\n    //const data = convertBits(result.data, 5, 8, false);\n    if (result.data.length !== 43) {\n        throw new Error('Invalid sapling address');\n    }\n    return { d: result.data.subarray(0, 11), pk_d: result.data.subarray(11) };\n};\nexports.decodeSaplingAddress = decodeSaplingAddress;\nconst encodeSaplingAddress = (data) => {\n    const buffer = Buffer.concat([data.d, data.pk_d]);\n    //const data = convertBits(buffer, 8, 5, false);\n    return (0, exports.toBech32)('zs', buffer);\n};\nexports.encodeSaplingAddress = encodeSaplingAddress;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}