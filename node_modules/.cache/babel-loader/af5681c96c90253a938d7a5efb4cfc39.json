{"ast":null,"code":"var assert = require('assert');\nvar BigInteger = require('bigi');\nvar Point = require('./point');\nfunction Curve(p, a, b, Gx, Gy, n, h) {\n  this.p = p;\n  this.a = a;\n  this.b = b;\n  this.G = Point.fromAffine(this, Gx, Gy);\n  this.n = n;\n  this.h = h;\n  this.infinity = new Point(this, null, null, BigInteger.ZERO);\n\n  // result caching\n  this.pOverFour = p.add(BigInteger.ONE).shiftRight(2);\n}\nCurve.prototype.pointFromX = function (isOdd, x) {\n  var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p);\n  var beta = alpha.modPow(this.pOverFour, this.p);\n  var y = beta;\n  if (beta.isEven() ^ !isOdd) {\n    y = this.p.subtract(y); // -y % p\n  }\n  return Point.fromAffine(this, x, y);\n};\nCurve.prototype.isInfinity = function (Q) {\n  if (Q === this.infinity) return true;\n  return Q.z.signum() === 0 && Q.y.signum() !== 0;\n};\nCurve.prototype.isOnCurve = function (Q) {\n  if (this.isInfinity(Q)) return true;\n  var x = Q.affineX;\n  var y = Q.affineY;\n  var a = this.a;\n  var b = this.b;\n  var p = this.p;\n\n  // Check that xQ and yQ are integers in the interval [0, p - 1]\n  if (x.signum() < 0 || x.compareTo(p) >= 0) return false;\n  if (y.signum() < 0 || y.compareTo(p) >= 0) return false;\n\n  // and check that y^2 = x^3 + ax + b (mod p)\n  var lhs = y.square().mod(p);\n  var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p);\n  return lhs.equals(rhs);\n};\n\n/**\n * Validate an elliptic curve point.\n *\n * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive\n */\nCurve.prototype.validate = function (Q) {\n  // Check Q != O\n  assert(!this.isInfinity(Q), 'Point is at infinity');\n  assert(this.isOnCurve(Q), 'Point is not on the curve');\n\n  // Check nQ = O (where Q is a scalar multiple of G)\n  var nQ = Q.multiply(this.n);\n  assert(this.isInfinity(nQ), 'Point is not a scalar multiple of G');\n  return true;\n};\nmodule.exports = Curve;","map":{"version":3,"names":["assert","require","BigInteger","Point","Curve","p","a","b","Gx","Gy","n","h","G","fromAffine","infinity","ZERO","pOverFour","add","ONE","shiftRight","prototype","pointFromX","isOdd","x","alpha","pow","multiply","mod","beta","modPow","y","isEven","subtract","isInfinity","Q","z","signum","isOnCurve","affineX","affineY","compareTo","lhs","square","rhs","equals","validate","nQ","module","exports"],"sources":["/Users/oddfl3x/Code/varB/NATIBridgeWebsite-main/node_modules/ecurve/lib/curve.js"],"sourcesContent":["var assert = require('assert')\nvar BigInteger = require('bigi')\n\nvar Point = require('./point')\n\nfunction Curve(p, a, b, Gx, Gy, n, h) {\n  this.p = p\n  this.a = a\n  this.b = b\n  this.G = Point.fromAffine(this, Gx, Gy)\n  this.n = n\n  this.h = h\n\n  this.infinity = new Point(this, null, null, BigInteger.ZERO)\n\n  // result caching\n  this.pOverFour = p.add(BigInteger.ONE).shiftRight(2)\n}\n\nCurve.prototype.pointFromX = function(isOdd, x) {\n  var alpha = x.pow(3).add(this.a.multiply(x)).add(this.b).mod(this.p)\n  var beta = alpha.modPow(this.pOverFour, this.p)\n\n  var y = beta\n  if (beta.isEven() ^ !isOdd) {\n    y = this.p.subtract(y) // -y % p\n  }\n\n  return Point.fromAffine(this, x, y)\n}\n\nCurve.prototype.isInfinity = function(Q) {\n  if (Q === this.infinity) return true\n\n  return Q.z.signum() === 0 && Q.y.signum() !== 0\n}\n\nCurve.prototype.isOnCurve = function(Q) {\n  if (this.isInfinity(Q)) return true\n\n  var x = Q.affineX\n  var y = Q.affineY\n  var a = this.a\n  var b = this.b\n  var p = this.p\n\n  // Check that xQ and yQ are integers in the interval [0, p - 1]\n  if (x.signum() < 0 || x.compareTo(p) >= 0) return false\n  if (y.signum() < 0 || y.compareTo(p) >= 0) return false\n\n  // and check that y^2 = x^3 + ax + b (mod p)\n  var lhs = y.square().mod(p)\n  var rhs = x.pow(3).add(a.multiply(x)).add(b).mod(p)\n  return lhs.equals(rhs)\n}\n\n/**\n * Validate an elliptic curve point.\n *\n * See SEC 1, section 3.2.2.1: Elliptic Curve Public Key Validation Primitive\n */\nCurve.prototype.validate = function(Q) {\n  // Check Q != O\n  assert(!this.isInfinity(Q), 'Point is at infinity')\n  assert(this.isOnCurve(Q), 'Point is not on the curve')\n\n  // Check nQ = O (where Q is a scalar multiple of G)\n  var nQ = Q.multiply(this.n)\n  assert(this.isInfinity(nQ), 'Point is not a scalar multiple of G')\n\n  return true\n}\n\nmodule.exports = Curve\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}