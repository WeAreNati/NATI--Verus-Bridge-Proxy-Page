{"ast":null,"code":"import { isETHAddress, isiAddress, isRAddress } from \"./rules\";\nimport { GLOBAL_ADDRESS, BLOCKCHAIN_NAME, FLAGS } from 'constants/contractAddress';\nexport const getTokenOptions = (poolAvailable, tokens) => poolAvailable ? tokens : tokens.filter(option => !(parseInt(option.flags) & FLAGS.MAPPING_ISBRIDGE_CURRENCY));\nexport const getDestinations = (token, addr) => [{\n  value: BLOCKCHAIN_NAME,\n  label: `${token !== null && token !== void 0 ? token : BLOCKCHAIN_NAME} on ${BLOCKCHAIN_NAME}`,\n  iaddress: addr\n}, {\n  value: \"bridgeBRIDGE\",\n  label: `Convert to Bridge.vETH on ${BLOCKCHAIN_NAME}`,\n  iaddress: GLOBAL_ADDRESS.BETH\n}, {\n  value: \"bridgeDAI\",\n  label: `Convert to DAI on ${BLOCKCHAIN_NAME}`,\n  iaddress: GLOBAL_ADDRESS.DAI\n}, {\n  value: \"bridgeVRSC\",\n  label: `Convert to ${BLOCKCHAIN_NAME} on ${BLOCKCHAIN_NAME}`,\n  iaddress: GLOBAL_ADDRESS.VRSC\n}, {\n  value: \"bridgeETH\",\n  label: `Convert to ETH on ${BLOCKCHAIN_NAME}`,\n  iaddress: GLOBAL_ADDRESS.ETH\n}, {\n  value: \"bridgeMKR\",\n  label: `Convert to MKR on ${BLOCKCHAIN_NAME}`,\n  iaddress: GLOBAL_ADDRESS.MKR\n}, {\n  value: \"swaptoBRIDGE\",\n  label: \"Convert to Bridge.vETH Token and (Bounce back to ETH)\",\n  iaddress: GLOBAL_ADDRESS.BETH\n}, {\n  value: \"swaptoVRSC\",\n  label: `Convert to ${BLOCKCHAIN_NAME} Token and (Bounce back to ETH)`,\n  iaddress: GLOBAL_ADDRESS.VRSC\n}, {\n  value: \"swaptoDAI\",\n  label: \"Convert to DAI Token and (Bounce back to ETH)\",\n  iaddress: GLOBAL_ADDRESS.DAI\n}, {\n  value: \"swaptoETH\",\n  label: \"Convert to ETH and (Bounce back to ETH)\",\n  iaddress: GLOBAL_ADDRESS.ETH\n}, {\n  value: \"swaptoMKR\",\n  label: \"Convert to MKR Token and (Bounce back to ETH)\",\n  iaddress: GLOBAL_ADDRESS.MKR\n}];\nconst destionationOptionsByPool = [\"swaptoBRIDGE\", \"swaptoVRSC\", 'bridgeBRIDGE', 'swaptoDAI', 'swaptoETH', \"swaptoMKR\"];\nexport const getDestinationOptions = (poolAvailable, address, selectedToken, tokenName) => {\n  // Destination currency is vrsc all curencies pre pool launch.\n  if (!address || !selectedToken) {\n    return [];\n  }\n  const options = !poolAvailable ? [{\n    value: BLOCKCHAIN_NAME,\n    label: `${tokenName !== null && tokenName !== void 0 ? tokenName : BLOCKCHAIN_NAME} on ${BLOCKCHAIN_NAME}`,\n    iaddress: selectedToken\n  }] : getDestinations(tokenName, selectedToken);\n  const addedToken = ![GLOBAL_ADDRESS.DAI, GLOBAL_ADDRESS.VRSC, GLOBAL_ADDRESS.BETH, GLOBAL_ADDRESS.ETH, GLOBAL_ADDRESS.MKR].includes(selectedToken);\n  if (isETHAddress(address)) {\n    const ethOptions = options.filter(option => ![BLOCKCHAIN_NAME, 'bridgeBRIDGE', 'bridgeDAI', 'bridgeVRSC', 'bridgeETH', 'bridgeMKR', `bridge${BLOCKCHAIN_NAME}`].includes(option.value));\n    if (addedToken) {\n      return []; //if its a mapped added token dont offer bounce back\n    }\n    if (selectedToken) {\n      return ethOptions.filter(option => option.iaddress !== selectedToken);\n    } else {\n      return ethOptions;\n    }\n  } else if (isiAddress(address) || isRAddress(address)) {\n    const vscOptions = options.filter(option => [BLOCKCHAIN_NAME, 'bridgeBRIDGE', 'bridgeDAI', 'bridgeVRSC', 'bridgeETH', 'bridgeMKR'].includes(option.value));\n    if (!poolAvailable || addedToken) {\n      return vscOptions.filter(option => option.value === BLOCKCHAIN_NAME);\n    } else {\n      return vscOptions.filter(option => option.iaddress !== selectedToken || option.value.slice(0, 6) !== 'bridge');\n    }\n  } else {\n    return options;\n  }\n};","map":{"version":3,"names":["isETHAddress","isiAddress","isRAddress","GLOBAL_ADDRESS","BLOCKCHAIN_NAME","FLAGS","getTokenOptions","poolAvailable","tokens","filter","option","parseInt","flags","MAPPING_ISBRIDGE_CURRENCY","getDestinations","token","addr","value","label","iaddress","BETH","DAI","VRSC","ETH","MKR","destionationOptionsByPool","getDestinationOptions","address","selectedToken","tokenName","options","addedToken","includes","ethOptions","vscOptions","slice"],"sources":["/Users/oddfl3x/Code/varB/vARRRBridgeWebsite-main/src/utils/options.js"],"sourcesContent":["import { isETHAddress, isiAddress, isRAddress } from \"./rules\";\nimport { GLOBAL_ADDRESS, BLOCKCHAIN_NAME, FLAGS } from 'constants/contractAddress';\n\nexport const getTokenOptions = (poolAvailable, tokens) => (\n  poolAvailable ? tokens : tokens.filter(option => !(parseInt(option.flags) & FLAGS.MAPPING_ISBRIDGE_CURRENCY))\n)\n\nexport const getDestinations = (token, addr) => ([\n  { value: BLOCKCHAIN_NAME, label: `${token ?? BLOCKCHAIN_NAME} on ${BLOCKCHAIN_NAME}`, iaddress: addr },\n  { value: \"bridgeBRIDGE\", label: `Convert to Bridge.vETH on ${BLOCKCHAIN_NAME}`, iaddress: GLOBAL_ADDRESS.BETH },\n  { value: \"bridgeDAI\", label: `Convert to DAI on ${BLOCKCHAIN_NAME}`, iaddress: GLOBAL_ADDRESS.DAI },\n  { value: \"bridgeVRSC\", label: `Convert to ${BLOCKCHAIN_NAME} on ${BLOCKCHAIN_NAME}`, iaddress: GLOBAL_ADDRESS.VRSC },\n  { value: \"bridgeETH\", label: `Convert to ETH on ${BLOCKCHAIN_NAME}`, iaddress: GLOBAL_ADDRESS.ETH },\n  { value: \"bridgeMKR\", label: `Convert to MKR on ${BLOCKCHAIN_NAME}`, iaddress: GLOBAL_ADDRESS.MKR },\n  { value: \"swaptoBRIDGE\", label: \"Convert to Bridge.vETH Token and (Bounce back to ETH)\", iaddress: GLOBAL_ADDRESS.BETH },\n  { value: \"swaptoVRSC\", label: `Convert to ${BLOCKCHAIN_NAME} Token and (Bounce back to ETH)`, iaddress: GLOBAL_ADDRESS.VRSC },\n  { value: \"swaptoDAI\", label: \"Convert to DAI Token and (Bounce back to ETH)\", iaddress: GLOBAL_ADDRESS.DAI },\n  { value: \"swaptoETH\", label: \"Convert to ETH and (Bounce back to ETH)\", iaddress: GLOBAL_ADDRESS.ETH },\n  { value: \"swaptoMKR\", label: \"Convert to MKR Token and (Bounce back to ETH)\", iaddress: GLOBAL_ADDRESS.MKR }\n]);\n\nconst destionationOptionsByPool = [\n  \"swaptoBRIDGE\", \"swaptoVRSC\", 'bridgeBRIDGE', 'swaptoDAI', 'swaptoETH', \"swaptoMKR\"\n]\n\nexport const getDestinationOptions = (poolAvailable, address, selectedToken, tokenName) => {\n\n  // Destination currency is vrsc all curencies pre pool launch.\n  if (!address || !selectedToken) {\n    return [];\n  }\n  const options = !poolAvailable\n    ? [{ value: BLOCKCHAIN_NAME, label: `${tokenName ?? BLOCKCHAIN_NAME} on ${BLOCKCHAIN_NAME}`, iaddress: selectedToken }]\n    : getDestinations(tokenName, selectedToken)\n\n  const addedToken = ![GLOBAL_ADDRESS.DAI, GLOBAL_ADDRESS.VRSC, GLOBAL_ADDRESS.BETH, GLOBAL_ADDRESS.ETH, GLOBAL_ADDRESS.MKR].includes(selectedToken);\n\n  if (isETHAddress(address)) {\n    const ethOptions = options.filter(option => ![BLOCKCHAIN_NAME, 'bridgeBRIDGE', 'bridgeDAI', 'bridgeVRSC', 'bridgeETH', 'bridgeMKR', `bridge${BLOCKCHAIN_NAME}`].includes(option.value));\n    if (addedToken) {\n      return [] //if its a mapped added token dont offer bounce back\n    }\n    if (selectedToken) {\n      return ethOptions.filter(option => option.iaddress !== selectedToken);\n    }\n    else {\n      return ethOptions\n    }\n  }\n  else if (isiAddress(address) || isRAddress(address)) {\n    const vscOptions = options.filter(option => [BLOCKCHAIN_NAME, 'bridgeBRIDGE', 'bridgeDAI', 'bridgeVRSC', 'bridgeETH', 'bridgeMKR'].includes(option.value));\n\n    if (!poolAvailable || addedToken) {\n      return vscOptions.filter(option => option.value === BLOCKCHAIN_NAME)\n    }\n\n    else {\n      return vscOptions.filter(option => (option.iaddress !== selectedToken) || (option.value.slice(0, 6) !== 'bridge'));\n    }\n  }\n  else {\n    return options;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}