{"ast":null,"code":"\"use strict\";\n\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\nconst _assert_js_1 = require(\"./_assert.js\");\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n  return a instanceof Uint8Array || a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array';\n}\nexports.isBytes = isBytes;\n// Cast array to different type\nconst u8 = arr => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = arr => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = arr => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => word << 32 - shift | word >>> shift;\nexports.rotr = rotr;\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;\nexports.rotl = rotl;\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = word => word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;\nexports.byteSwap = byteSwap;\n// Conditionally byte swap if on a big-endian platform\nexports.byteSwapIfBE = exports.isLE ? n => n : n => (0, exports.byteSwap)(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = (0, exports.byteSwap)(arr[i]);\n  }\n}\nexports.byteSwap32 = byteSwap32;\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */Array.from({\n  length: 256\n}, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n  (0, _assert_js_1.bytes)(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\nexports.bytesToHex = bytesToHex;\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n  _0: 48,\n  _9: 57,\n  _A: 65,\n  _F: 70,\n  _a: 97,\n  _f: 102\n};\nfunction asciiToBase16(char) {\n  if (char >= asciis._0 && char <= asciis._9) return char - asciis._0;\n  if (char >= asciis._A && char <= asciis._F) return char - (asciis._A - 10);\n  if (char >= asciis._a && char <= asciis._f) return char - (asciis._a - 10);\n  return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2;\n  }\n  return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => {};\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await (0, exports.nextTick)();\n    ts += diff;\n  }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') throw new Error(\"utf8ToBytes expected string, got \".concat(typeof str));\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  (0, _assert_js_1.bytes)(data);\n  return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes() {\n  let sum = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    const a = i < 0 || arguments.length <= i ? undefined : arguments[i];\n    (0, _assert_js_1.bytes)(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arguments.length; i++) {\n    const a = i < 0 || arguments.length <= i ? undefined : arguments[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n  // Safe version that clones internal state\n  clone() {\n    return this._cloneInto();\n  }\n}\nexports.Hash = Hash;\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n  if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n  const hashC = msg => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = opts => hashCons(opts);\n  return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({});\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = opts => hashCons(opts);\n  return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes() {\n  let bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;\n  if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n    return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\nexports.randomBytes = randomBytes;","map":{"version":3,"sources":["src/utils.ts"],"names":[],"mappings":";;AAAA;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AACA;AACA;AACA,SAAgB,OAAO,CAAC,CAAU,EAAA;EAChC,OACE,CAAC,YAAY,UAAU,IACtB,CAAC,IAAI,IAAI,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,CAAC,CAAC,WAAW,CAAC,IAAI,KAAK,YAAa;AAE/E;AALA,OAAA,CAAA,OAAA,GAAA,OAAA;AAWA;AACO,MAAM,EAAE,GAAI,GAAe,IAAK,IAAI,UAAU,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU,CAAC;AAApF,OAAA,CAAA,EAAE,GAAA,EAAA;AACR,MAAM,GAAG,GAAI,GAAe,IACjC,IAAI,WAAW,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;AADhE,OAAA,CAAA,GAAG,GAAA,GAAA;AAGhB;AACO,MAAM,UAAU,GAAI,GAAe,IACxC,IAAI,QAAQ,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,UAAU,EAAE,GAAG,CAAC,UAAU,CAAC;AAD7C,OAAA,CAAA,UAAU,GAAA,UAAA;AAGvB;AACO,MAAM,IAAI,GAAG,CAAC,IAAY,EAAE,KAAa,KAAM,IAAI,IAAK,EAAE,GAAG,KAAM,GAAK,IAAI,KAAK,KAAM;AAAjF,OAAA,CAAA,IAAI,GAAA,IAAA;AACjB;AACO,MAAM,IAAI,GAAG,CAAC,IAAY,EAAE,KAAa,KAC7C,IAAI,IAAI,KAAK,GAAM,IAAI,KAAM,EAAE,GAAG,KAAM,KAAM,CAAE;AADtC,OAAA,CAAA,IAAI,GAAA,IAAA;AAGJ,OAAA,CAAA,IAAI,GAAG,IAAI,UAAU,CAAC,IAAI,WAAW,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,IAAI;AACpF;AACO,MAAM,QAAQ,GAAI,IAAY,IACjC,IAAI,IAAI,EAAE,GAAI,UAAU,GACxB,IAAI,IAAI,CAAC,GAAI,QAAS,GACtB,IAAI,KAAK,CAAC,GAAI,MAAO,GACrB,IAAI,KAAK,EAAE,GAAI,IAAK;AAJX,OAAA,CAAA,QAAQ,GAAA,QAAA;AAKrB;AACa,OAAA,CAAA,YAAY,GAAG,OAAA,CAAA,IAAI,GAAI,CAAS,IAAK,CAAC,GAAI,CAAS,IAAK,CAAA,CAAA,EAAA,OAAA,CAAA,QAAQ,EAAC,CAAC,CAAC;AAEhF;AACA,SAAgB,UAAU,CAAC,GAAgB,EAAA;EACzC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACnC,GAAG,CAAC,CAAC,CAAC,GAAG,CAAA,CAAA,EAAA,OAAA,CAAA,QAAQ,EAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC3B;AACF;AAJA,OAAA,CAAA,UAAA,GAAA,UAAA;AAMA;AACA,MAAM,KAAK,GAAG,eAAgB,KAAK,CAAC,IAAI,CAAC;EAAE,MAAM,EAAE;AAAG,CAAE,EAAE,CAAC,CAAC,EAAE,CAAC,KAC7D,CAAC,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,EAAE,GAAG,CAAC,CAChC;AACD;;AAEG;AACH,SAAgB,UAAU,CAAC,KAAiB,EAAA;EAC1C,CAAA,CAAA,EAAA,YAAA,CAAA,KAAM,EAAC,KAAK,CAAC;EACb;EACA,IAAI,GAAG,GAAG,EAAE;EACZ,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;IACrC,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;EACxB;EACA,OAAO,GAAG;AACZ;AARA,OAAA,CAAA,UAAA,GAAA,UAAA;AAUA;AACA,MAAM,MAAM,GAAG;EAAE,EAAE,EAAE,EAAE;EAAE,EAAE,EAAE,EAAE;EAAE,EAAE,EAAE,EAAE;EAAE,EAAE,EAAE,EAAE;EAAE,EAAE,EAAE,EAAE;EAAE,EAAE,EAAE;AAAG,CAAW;AAC3E,SAAS,aAAa,CAAC,IAAY,EAAA;EACjC,IAAI,IAAI,IAAI,MAAM,CAAC,EAAE,IAAI,IAAI,IAAI,MAAM,CAAC,EAAE,EAAE,OAAO,IAAI,GAAG,MAAM,CAAC,EAAE;EACnE,IAAI,IAAI,IAAI,MAAM,CAAC,EAAE,IAAI,IAAI,IAAI,MAAM,CAAC,EAAE,EAAE,OAAO,IAAI,IAAI,MAAM,CAAC,EAAE,GAAG,EAAE,CAAC;EAC1E,IAAI,IAAI,IAAI,MAAM,CAAC,EAAE,IAAI,IAAI,IAAI,MAAM,CAAC,EAAE,EAAE,OAAO,IAAI,IAAI,MAAM,CAAC,EAAE,GAAG,EAAE,CAAC;EAC1E;AACF;AAEA;;AAEG;AACH,SAAgB,UAAU,CAAC,GAAW,EAAA;EACpC,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,MAAM,IAAI,KAAK,CAAC,2BAA2B,GAAG,OAAO,GAAG,CAAC;EACtF,MAAM,EAAE,GAAG,GAAG,CAAC,MAAM;EACrB,MAAM,EAAE,GAAG,EAAE,GAAG,CAAC;EACjB,IAAI,EAAE,GAAG,CAAC,EAAE,MAAM,IAAI,KAAK,CAAC,yDAAyD,GAAG,EAAE,CAAC;EAC3F,MAAM,KAAK,GAAG,IAAI,UAAU,CAAC,EAAE,CAAC;EAChC,KAAK,IAAI,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,IAAI,CAAC,EAAE;IAC/C,MAAM,EAAE,GAAG,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;IAC5C,MAAM,EAAE,GAAG,aAAa,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;IAChD,IAAI,EAAE,KAAK,SAAS,IAAI,EAAE,KAAK,SAAS,EAAE;MACxC,MAAM,IAAI,GAAG,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,EAAE,GAAG,CAAC,CAAC;MAClC,MAAM,IAAI,KAAK,CAAC,8CAA8C,GAAG,IAAI,GAAG,aAAa,GAAG,EAAE,CAAC;IAC7F;IACA,KAAK,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE;EAC1B;EACA,OAAO,KAAK;AACd;AAhBA,OAAA,CAAA,UAAA,GAAA,UAAA;AAkBA;AACA;AACA;AACO,MAAM,QAAQ,GAAG,MAAA,CAAA,KAAW,CAAE,CAAC;AAAzB,OAAA,CAAA,QAAQ,GAAA,QAAA;AAErB;AACO,eAAe,SAAS,CAAC,KAAa,EAAE,IAAY,EAAE,EAAuB,EAAA;EAClF,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,CAAA,CAAE;EACnB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,EAAE,EAAE;IAC9B,EAAE,CAAC,CAAC,CAAC;IACL;IACA,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,CAAA,CAAE,GAAG,EAAE;IAC5B,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,GAAG,IAAI,EAAE;IAC9B,MAAM,CAAA,CAAA,EAAA,OAAA,CAAA,QAAQ,EAAA,CAAE;IAChB,EAAE,IAAI,IAAI;EACZ;AACF;AAVA,OAAA,CAAA,SAAA,GAAA,SAAA;AAgBA;;AAEG;AACH,SAAgB,WAAW,CAAC,GAAW,EAAA;EACrC,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE,MAAM,IAAI,KAAK,qCAAA,MAAA,CAAqC,OAAO,GAAG,CAAE,CAAC;EAC9F,OAAO,IAAI,UAAU,CAAC,IAAI,WAAW,CAAA,CAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;AACxD;AAHA,OAAA,CAAA,WAAA,GAAA,WAAA;AAMA;;;;AAIG;AACH,SAAgB,OAAO,CAAC,IAAW,EAAA;EACjC,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE,IAAI,GAAG,WAAW,CAAC,IAAI,CAAC;EACtD,CAAA,CAAA,EAAA,YAAA,CAAA,KAAM,EAAC,IAAI,CAAC;EACZ,OAAO,IAAI;AACb;AAJA,OAAA,CAAA,OAAA,GAAA,OAAA;AAMA;;AAEG;AACH,SAAgB,WAAW,CAAA,EAAwB;EACjD,IAAI,GAAG,GAAG,CAAC;EACX,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAA,CAAO,MAAM,EAAE,CAAC,EAAE,EAAE;IACtC,MAAM,CAAC,GAAU,CAAC,QAAA,SAAA,CAAA,MAAA,IAAD,CAAC,GAAA,SAAA,GAAA,SAAA,CAAD,CAAC,CAAC;IACnB,CAAA,CAAA,EAAA,YAAA,CAAA,KAAM,EAAC,CAAC,CAAC;IACT,GAAG,IAAI,CAAC,CAAC,MAAM;EACjB;EACA,MAAM,GAAG,GAAG,IAAI,UAAU,CAAC,GAAG,CAAC;EAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE,CAAC,GAAG,SAAA,CAAO,MAAM,EAAE,CAAC,EAAE,EAAE;IAC/C,MAAM,CAAC,GAAU,CAAC,QAAA,SAAA,CAAA,MAAA,IAAD,CAAC,GAAA,SAAA,GAAA,SAAA,CAAD,CAAC,CAAC;IACnB,GAAG,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC;IACf,GAAG,IAAI,CAAC,CAAC,MAAM;EACjB;EACA,OAAO,GAAG;AACZ;AAdA,OAAA,CAAA,WAAA,GAAA,WAAA;AAgBA;AACA,MAAsB,IAAI,CAAA;EAqBxB;EACA,KAAK,CAAA,EAAA;IACH,OAAO,IAAI,CAAC,UAAU,CAAA,CAAE;EAC1B;AACD;AAzBD,OAAA,CAAA,IAAA,GAAA,IAAA;AAsCA,MAAM,KAAK,GAAG,CAAA,CAAE,CAAC,QAAQ;AAEzB,SAAgB,SAAS,CACvB,QAAY,EACZ,IAAS,EAAA;EAET,IAAI,IAAI,KAAK,SAAS,IAAI,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,iBAAiB,EAC9D,MAAM,IAAI,KAAK,CAAC,uCAAuC,CAAC;EAC1D,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC;EAC5C,OAAO,MAAiB;AAC1B;AARA,OAAA,CAAA,SAAA,GAAA,SAAA;AAYA,SAAgB,eAAe,CAAoB,QAAuB,EAAA;EACxE,MAAM,KAAK,GAAI,GAAU,IAAiB,QAAQ,CAAA,CAAE,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAA,CAAE;EAClF,MAAM,GAAG,GAAG,QAAQ,CAAA,CAAE;EACtB,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,SAAS;EAC/B,KAAK,CAAC,QAAQ,GAAG,GAAG,CAAC,QAAQ;EAC7B,KAAK,CAAC,MAAM,GAAG,MAAM,QAAQ,CAAA,CAAE;EAC/B,OAAO,KAAK;AACd;AAPA,OAAA,CAAA,eAAA,GAAA,eAAA;AASA,SAAgB,uBAAuB,CACrC,QAA+B,EAAA;EAE/B,MAAM,KAAK,GAAG,CAAC,GAAU,EAAE,IAAQ,KAAiB,QAAQ,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAA,CAAE;EAChG,MAAM,GAAG,GAAG,QAAQ,CAAC,CAAA,CAAO,CAAC;EAC7B,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,SAAS;EAC/B,KAAK,CAAC,QAAQ,GAAG,GAAG,CAAC,QAAQ;EAC7B,KAAK,CAAC,MAAM,GAAI,IAAO,IAAK,QAAQ,CAAC,IAAI,CAAC;EAC1C,OAAO,KAAK;AACd;AATA,OAAA,CAAA,uBAAA,GAAA,uBAAA;AAWA,SAAgB,0BAA0B,CACxC,QAAkC,EAAA;EAElC,MAAM,KAAK,GAAG,CAAC,GAAU,EAAE,IAAQ,KAAiB,QAAQ,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAA,CAAE;EAChG,MAAM,GAAG,GAAG,QAAQ,CAAC,CAAA,CAAO,CAAC;EAC7B,KAAK,CAAC,SAAS,GAAG,GAAG,CAAC,SAAS;EAC/B,KAAK,CAAC,QAAQ,GAAG,GAAG,CAAC,QAAQ;EAC7B,KAAK,CAAC,MAAM,GAAI,IAAO,IAAK,QAAQ,CAAC,IAAI,CAAC;EAC1C,OAAO,KAAK;AACd;AATA,OAAA,CAAA,0BAAA,GAAA,0BAAA;AAWA;;AAEG;AACH,SAAgB,WAAW,CAAA,EAAiB;EAAA,IAAhB,WAAW,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAG,EAAE;EAC1C,IAAI,QAAA,CAAA,MAAM,IAAI,OAAO,QAAA,CAAA,MAAM,CAAC,eAAe,KAAK,UAAU,EAAE;IAC1D,OAAO,QAAA,CAAA,MAAM,CAAC,eAAe,CAAC,IAAI,UAAU,CAAC,WAAW,CAAC,CAAC;EAC5D;EACA,MAAM,IAAI,KAAK,CAAC,wCAAwC,CAAC;AAC3D;AALA,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = require(\"@noble/hashes/crypto\");\nconst _assert_js_1 = require(\"./_assert.js\");\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nexports.isBytes = isBytes;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.u8 = u8;\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\nexports.u32 = u32;\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nexports.createView = createView;\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\nexports.rotr = rotr;\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nexports.rotl = rotl;\nexports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\nexports.byteSwap = byteSwap;\n// Conditionally byte swap if on a big-endian platform\nexports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = (0, exports.byteSwap)(arr[i]);\n    }\n}\nexports.byteSwap32 = byteSwap32;\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0, _assert_js_1.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nexports.bytesToHex = bytesToHex;\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nexports.hexToBytes = hexToBytes;\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\nexports.asyncLoop = asyncLoop;\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nexports.utf8ToBytes = utf8ToBytes;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0, _assert_js_1.bytes)(data);\n    return data;\n}\nexports.toBytes = toBytes;\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0, _assert_js_1.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nexports.concatBytes = concatBytes;\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.Hash = Hash;\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nexports.checkOpts = checkOpts;\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nexports.wrapConstructor = wrapConstructor;\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructorWithOpts = wrapConstructorWithOpts;\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\nexports.randomBytes = randomBytes;\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}