{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContentMultiMap = exports.isKvValueArrayItemVdxfUniValueJson = void 0;\nconst varuint_1 = require(\"../utils/varuint\");\nconst bufferutils_1 = require(\"../utils/bufferutils\");\nconst address_1 = require(\"../utils/address\");\nconst vdxf_1 = require(\"../constants/vdxf\");\nconst VdxfUniValue_1 = require(\"./VdxfUniValue\");\nconst string_1 = require(\"../utils/string\");\nconst {\n  BufferReader,\n  BufferWriter\n} = bufferutils_1.default;\nfunction isKvValueArrayItemVdxfUniValueJson(x) {\n  return x != null && typeof x === 'object' && !Array.isArray(x) && Object.keys(x).every(key => {\n    const val = x[key];\n    try {\n      const {\n        version,\n        hash\n      } = (0, address_1.fromBase58Check)(key);\n      return version === vdxf_1.I_ADDR_VERSION && (Buffer.isBuffer(val) || typeof val === 'string');\n    } catch (e) {\n      return false;\n    }\n  });\n}\nexports.isKvValueArrayItemVdxfUniValueJson = isKvValueArrayItemVdxfUniValueJson;\nclass ContentMultiMap {\n  constructor(data) {\n    if (data === null || data === void 0 ? void 0 : data.kv_content) this.kv_content = data.kv_content;\n  }\n  getByteLength() {\n    let length = 0;\n    length += varuint_1.default.encodingLength(this.kv_content.size);\n    for (const [key, value] of this.kv_content.entries()) {\n      length += (0, address_1.fromBase58Check)(key).hash.length;\n      if (Array.isArray(value)) {\n        const valueArr = value;\n        length += varuint_1.default.encodingLength(valueArr.length);\n        for (const n of value) {\n          if (n instanceof VdxfUniValue_1.VdxfUniValue) {\n            const nCMMNOLength = n.getByteLength();\n            length += varuint_1.default.encodingLength(nCMMNOLength);\n            length += nCMMNOLength;\n          } else if (Buffer.isBuffer(n)) {\n            const nBuf = n;\n            length += varuint_1.default.encodingLength(nBuf.length);\n            length += nBuf.length;\n          } else throw new Error(\"Unknown ContentMultiMap data, can't calculate ByteLength\");\n        }\n      } else throw new Error(\"Unknown ContentMultiMap data, can't calculate ByteLength\");\n    }\n    return length;\n  }\n  toBuffer() {\n    const writer = new BufferWriter(Buffer.alloc(this.getByteLength()));\n    writer.writeCompactSize(this.kv_content.size);\n    for (const [key, value] of this.kv_content.entries()) {\n      writer.writeSlice((0, address_1.fromBase58Check)(key).hash);\n      if (Array.isArray(value)) {\n        writer.writeCompactSize(value.length);\n        for (const n of value) {\n          if (n instanceof VdxfUniValue_1.VdxfUniValue) {\n            const nCMMNOBuf = n.toBuffer();\n            writer.writeVarSlice(nCMMNOBuf);\n          } else if (Buffer.isBuffer(n)) {\n            const nBuf = n;\n            writer.writeVarSlice(nBuf);\n          } else throw new Error(\"Unknown ContentMultiMap data, can't toBuffer\");\n        }\n      } else throw new Error(\"Unknown ContentMultiMap data, can't toBuffer\");\n    }\n    return writer.buffer;\n  }\n  fromBuffer(buffer, offset = 0, keylists = []) {\n    const reader = new BufferReader(buffer, offset);\n    const contentMultiMapSize = reader.readVarInt();\n    this.kv_content = new Map();\n    for (var i = 0; i < contentMultiMapSize.toNumber(); i++) {\n      const keylist = i < keylists.length ? keylists[i] : null;\n      const contentMapKey = (0, address_1.toBase58Check)(reader.readSlice(20), vdxf_1.I_ADDR_VERSION);\n      const vector = [];\n      const count = reader.readCompactSize();\n      for (let j = 0; j < count; j++) {\n        if (keylist) {\n          const unival = new VdxfUniValue_1.VdxfUniValue();\n          unival.fromBuffer(reader.readVarSlice(), 0, keylist);\n          vector.push(unival);\n        } else vector.push(reader.readVarSlice());\n      }\n      this.kv_content.set(contentMapKey, vector);\n    }\n    return reader.offset;\n  }\n  static fromJson(obj) {\n    const content = new Map();\n    for (const key in obj) {\n      const keybytes = (0, address_1.fromBase58Check)(key).hash;\n      const value = obj[key];\n      if (keybytes && value != null) {\n        if (Array.isArray(value)) {\n          const items = [];\n          for (const x of value) {\n            if (typeof x === 'string') {\n              items.push(Buffer.from(x, 'hex'));\n            } else if (typeof x === 'object' && x != null) {\n              const uniVal = VdxfUniValue_1.VdxfUniValue.fromJson(x);\n              if (uniVal.toBuffer().length > 0) {\n                items.push(uniVal);\n              }\n            }\n          }\n          content.set(key, items);\n        } else if (typeof value === 'string' && (0, string_1.isHexString)(value)) {\n          content.set(key, [Buffer.from(value, 'hex')]);\n        } else if (isKvValueArrayItemVdxfUniValueJson(value)) {\n          content.set(key, [VdxfUniValue_1.VdxfUniValue.fromJson(value)]);\n        } else {\n          throw new Error(\"Invalid data in multimap\");\n        }\n      }\n    }\n    return new ContentMultiMap({\n      kv_content: content\n    });\n  }\n  toJson() {\n    const ret = {};\n    for (const [key, value] of this.kv_content.entries()) {\n      if (Array.isArray(value)) {\n        const items = [];\n        for (const n of value) {\n          if (n instanceof VdxfUniValue_1.VdxfUniValue) {\n            items.push(n.toJson());\n          } else if (Buffer.isBuffer(n)) {\n            items.push(n.toString('hex'));\n          } else throw new Error(\"Unknown ContentMultiMap data, can't toBuffer\");\n        }\n        ret[key] = items;\n      } else throw new Error(\"Unknown ContentMultiMap data, can't toBuffer\");\n    }\n    return ret;\n  }\n}\nexports.ContentMultiMap = ContentMultiMap;","map":{"version":3,"names":["Object","defineProperty","exports","value","ContentMultiMap","isKvValueArrayItemVdxfUniValueJson","varuint_1","require","bufferutils_1","address_1","vdxf_1","VdxfUniValue_1","string_1","BufferReader","BufferWriter","default","x","Array","isArray","keys","every","key","val","version","hash","fromBase58Check","I_ADDR_VERSION","Buffer","isBuffer","e","constructor","data","kv_content","getByteLength","length","encodingLength","size","entries","valueArr","n","VdxfUniValue","nCMMNOLength","nBuf","Error","toBuffer","writer","alloc","writeCompactSize","writeSlice","nCMMNOBuf","writeVarSlice","buffer","fromBuffer","offset","keylists","reader","contentMultiMapSize","readVarInt","Map","i","toNumber","keylist","contentMapKey","toBase58Check","readSlice","vector","count","readCompactSize","j","unival","readVarSlice","push","set","fromJson","obj","content","keybytes","items","from","uniVal","isHexString","toJson","ret","toString"],"sources":["/Users/oddfl3x/Code/varB/NATIBridgeWebsite-main/node_modules/verus-typescript-primitives/dist/pbaas/ContentMultiMap.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ContentMultiMap = exports.isKvValueArrayItemVdxfUniValueJson = void 0;\nconst varuint_1 = require(\"../utils/varuint\");\nconst bufferutils_1 = require(\"../utils/bufferutils\");\nconst address_1 = require(\"../utils/address\");\nconst vdxf_1 = require(\"../constants/vdxf\");\nconst VdxfUniValue_1 = require(\"./VdxfUniValue\");\nconst string_1 = require(\"../utils/string\");\nconst { BufferReader, BufferWriter } = bufferutils_1.default;\nfunction isKvValueArrayItemVdxfUniValueJson(x) {\n    return x != null && typeof x === 'object' && !Array.isArray(x) && Object.keys(x).every((key) => {\n        const val = x[key];\n        try {\n            const { version, hash } = (0, address_1.fromBase58Check)(key);\n            return version === vdxf_1.I_ADDR_VERSION && (Buffer.isBuffer(val) || typeof val === 'string');\n        }\n        catch (e) {\n            return false;\n        }\n    });\n}\nexports.isKvValueArrayItemVdxfUniValueJson = isKvValueArrayItemVdxfUniValueJson;\nclass ContentMultiMap {\n    constructor(data) {\n        if (data === null || data === void 0 ? void 0 : data.kv_content)\n            this.kv_content = data.kv_content;\n    }\n    getByteLength() {\n        let length = 0;\n        length += varuint_1.default.encodingLength(this.kv_content.size);\n        for (const [key, value] of this.kv_content.entries()) {\n            length += (0, address_1.fromBase58Check)(key).hash.length;\n            if (Array.isArray(value)) {\n                const valueArr = value;\n                length += varuint_1.default.encodingLength(valueArr.length);\n                for (const n of value) {\n                    if (n instanceof VdxfUniValue_1.VdxfUniValue) {\n                        const nCMMNOLength = n.getByteLength();\n                        length += varuint_1.default.encodingLength(nCMMNOLength);\n                        length += nCMMNOLength;\n                    }\n                    else if (Buffer.isBuffer(n)) {\n                        const nBuf = n;\n                        length += varuint_1.default.encodingLength(nBuf.length);\n                        length += nBuf.length;\n                    }\n                    else\n                        throw new Error(\"Unknown ContentMultiMap data, can't calculate ByteLength\");\n                }\n            }\n            else\n                throw new Error(\"Unknown ContentMultiMap data, can't calculate ByteLength\");\n        }\n        return length;\n    }\n    toBuffer() {\n        const writer = new BufferWriter(Buffer.alloc(this.getByteLength()));\n        writer.writeCompactSize(this.kv_content.size);\n        for (const [key, value] of this.kv_content.entries()) {\n            writer.writeSlice((0, address_1.fromBase58Check)(key).hash);\n            if (Array.isArray(value)) {\n                writer.writeCompactSize(value.length);\n                for (const n of value) {\n                    if (n instanceof VdxfUniValue_1.VdxfUniValue) {\n                        const nCMMNOBuf = n.toBuffer();\n                        writer.writeVarSlice(nCMMNOBuf);\n                    }\n                    else if (Buffer.isBuffer(n)) {\n                        const nBuf = n;\n                        writer.writeVarSlice(nBuf);\n                    }\n                    else\n                        throw new Error(\"Unknown ContentMultiMap data, can't toBuffer\");\n                }\n            }\n            else\n                throw new Error(\"Unknown ContentMultiMap data, can't toBuffer\");\n        }\n        return writer.buffer;\n    }\n    fromBuffer(buffer, offset = 0, keylists = []) {\n        const reader = new BufferReader(buffer, offset);\n        const contentMultiMapSize = reader.readVarInt();\n        this.kv_content = new Map();\n        for (var i = 0; i < contentMultiMapSize.toNumber(); i++) {\n            const keylist = i < keylists.length ? keylists[i] : null;\n            const contentMapKey = (0, address_1.toBase58Check)(reader.readSlice(20), vdxf_1.I_ADDR_VERSION);\n            const vector = [];\n            const count = reader.readCompactSize();\n            for (let j = 0; j < count; j++) {\n                if (keylist) {\n                    const unival = new VdxfUniValue_1.VdxfUniValue();\n                    unival.fromBuffer(reader.readVarSlice(), 0, keylist);\n                    vector.push(unival);\n                }\n                else\n                    vector.push(reader.readVarSlice());\n            }\n            this.kv_content.set(contentMapKey, vector);\n        }\n        return reader.offset;\n    }\n    static fromJson(obj) {\n        const content = new Map();\n        for (const key in obj) {\n            const keybytes = (0, address_1.fromBase58Check)(key).hash;\n            const value = obj[key];\n            if (keybytes && value != null) {\n                if (Array.isArray(value)) {\n                    const items = [];\n                    for (const x of value) {\n                        if (typeof x === 'string') {\n                            items.push(Buffer.from(x, 'hex'));\n                        }\n                        else if (typeof x === 'object' && x != null) {\n                            const uniVal = VdxfUniValue_1.VdxfUniValue.fromJson(x);\n                            if (uniVal.toBuffer().length > 0) {\n                                items.push(uniVal);\n                            }\n                        }\n                    }\n                    content.set(key, items);\n                }\n                else if (typeof value === 'string' && (0, string_1.isHexString)(value)) {\n                    content.set(key, [Buffer.from(value, 'hex')]);\n                }\n                else if (isKvValueArrayItemVdxfUniValueJson(value)) {\n                    content.set(key, [VdxfUniValue_1.VdxfUniValue.fromJson(value)]);\n                }\n                else {\n                    throw new Error(\"Invalid data in multimap\");\n                }\n            }\n        }\n        return new ContentMultiMap({ kv_content: content });\n    }\n    toJson() {\n        const ret = {};\n        for (const [key, value] of this.kv_content.entries()) {\n            if (Array.isArray(value)) {\n                const items = [];\n                for (const n of value) {\n                    if (n instanceof VdxfUniValue_1.VdxfUniValue) {\n                        items.push(n.toJson());\n                    }\n                    else if (Buffer.isBuffer(n)) {\n                        items.push(n.toString('hex'));\n                    }\n                    else\n                        throw new Error(\"Unknown ContentMultiMap data, can't toBuffer\");\n                }\n                ret[key] = items;\n            }\n            else\n                throw new Error(\"Unknown ContentMultiMap data, can't toBuffer\");\n        }\n        return ret;\n    }\n}\nexports.ContentMultiMap = ContentMultiMap;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}