{"ast":null,"code":"// m [pubKeys ...] n OP_CHECKMULTISIG\nvar bscript = require('../../script');\nvar types = require('../../types');\nvar typeforce = require('typeforce');\nvar OPS = require('bitcoin-ops');\nvar OptCCParams = require('../../optccparams');\nvar OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\nfunction check(script) {\n  var chunks = bscript.decompile(script);\n  // chunks for a smart transaction should include a push of either a CC or empty/master COptCCParams, then an OP_CHECKCRYPTOCONDITION,\n  // then a potentially nested COptCCParams\n  // we always start by decoding the second COptCCParams first to determine if the first one should be an opaque CC, as it was\n  // in earlier versions. if not, it is added to the end of the data objects of the first params\n  if (chunks.length < 4 || !(chunks[chunks.length - 1] === OPS.OP_DROP && chunks[1] === OPS.OP_CHECKCRYPTOCONDITION)) {\n    return false;\n  }\n  var params = OptCCParams.fromChunk(chunks[2]);\n  var master = OptCCParams.fromChunk(chunks[0]);\n  if (!params.isValid() || !master.isValid()) {\n    return false;\n  }\n  // now validate eval codes, object presence, currencies, types, etc.\n  return true;\n}\ncheck.toJSON = function () {\n  return 'smart transaction output';\n};\nfunction encode(m, pubKeys) {\n  typeforce({\n    m: types.Number,\n    pubKeys: [bscript.isCanonicalPubKey]\n  }, {\n    m: m,\n    pubKeys: pubKeys\n  });\n  var n = pubKeys.length;\n  if (n < m) throw new TypeError('Not enough pubKeys provided');\n  return bscript.compile([].concat(OP_INT_BASE + m, pubKeys, OP_INT_BASE + n, OPS.OP_CHECKMULTISIG));\n}\nfunction decode(buffer, allowIncomplete) {\n  var chunks = bscript.decompile(buffer);\n  typeforce(check, chunks, allowIncomplete);\n  return {\n    m: chunks[0] - OP_INT_BASE,\n    pubKeys: chunks.slice(1, -2)\n  };\n}\nmodule.exports = {\n  check: check,\n  decode: decode,\n  encode: encode\n};","map":{"version":3,"names":["bscript","require","types","typeforce","OPS","OptCCParams","OP_INT_BASE","OP_RESERVED","check","script","chunks","decompile","length","OP_DROP","OP_CHECKCRYPTOCONDITION","params","fromChunk","master","isValid","toJSON","encode","m","pubKeys","Number","isCanonicalPubKey","n","TypeError","compile","concat","OP_CHECKMULTISIG","decode","buffer","allowIncomplete","slice","module","exports"],"sources":["/Users/oddfl3x/Code/varB/NATI<>Verus Bridge Proxy Page/node_modules/@bitgo/utxo-lib/dist/src/templates/smarttransaction/output.js"],"sourcesContent":["// m [pubKeys ...] n OP_CHECKMULTISIG\nvar bscript = require('../../script');\nvar types = require('../../types');\nvar typeforce = require('typeforce');\nvar OPS = require('bitcoin-ops');\nvar OptCCParams = require('../../optccparams');\nvar OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\nfunction check(script) {\n    var chunks = bscript.decompile(script);\n    // chunks for a smart transaction should include a push of either a CC or empty/master COptCCParams, then an OP_CHECKCRYPTOCONDITION,\n    // then a potentially nested COptCCParams\n    // we always start by decoding the second COptCCParams first to determine if the first one should be an opaque CC, as it was\n    // in earlier versions. if not, it is added to the end of the data objects of the first params\n    if (chunks.length < 4 ||\n        !(chunks[chunks.length - 1] === OPS.OP_DROP && chunks[1] === OPS.OP_CHECKCRYPTOCONDITION)) {\n        return false;\n    }\n    var params = OptCCParams.fromChunk(chunks[2]);\n    var master = OptCCParams.fromChunk(chunks[0]);\n    if (!params.isValid() || !master.isValid()) {\n        return false;\n    }\n    // now validate eval codes, object presence, currencies, types, etc.\n    return true;\n}\ncheck.toJSON = function () { return 'smart transaction output'; };\nfunction encode(m, pubKeys) {\n    typeforce({\n        m: types.Number,\n        pubKeys: [bscript.isCanonicalPubKey]\n    }, {\n        m: m,\n        pubKeys: pubKeys\n    });\n    var n = pubKeys.length;\n    if (n < m)\n        throw new TypeError('Not enough pubKeys provided');\n    return bscript.compile([].concat(OP_INT_BASE + m, pubKeys, OP_INT_BASE + n, OPS.OP_CHECKMULTISIG));\n}\nfunction decode(buffer, allowIncomplete) {\n    var chunks = bscript.decompile(buffer);\n    typeforce(check, chunks, allowIncomplete);\n    return {\n        m: chunks[0] - OP_INT_BASE,\n        pubKeys: chunks.slice(1, -2)\n    };\n}\nmodule.exports = {\n    check: check,\n    decode: decode,\n    encode: encode\n};\n"],"mappings":"AAAA;AACA,IAAIA,OAAO,GAAGC,OAAO,CAAC,cAAc,CAAC;AACrC,IAAIC,KAAK,GAAGD,OAAO,CAAC,aAAa,CAAC;AAClC,IAAIE,SAAS,GAAGF,OAAO,CAAC,WAAW,CAAC;AACpC,IAAIG,GAAG,GAAGH,OAAO,CAAC,aAAa,CAAC;AAChC,IAAII,WAAW,GAAGJ,OAAO,CAAC,mBAAmB,CAAC;AAC9C,IAAIK,WAAW,GAAGF,GAAG,CAACG,WAAW,CAAC,CAAC;AACnC,SAASC,KAAKA,CAACC,MAAM,EAAE;EACnB,IAAIC,MAAM,GAAGV,OAAO,CAACW,SAAS,CAACF,MAAM,CAAC;EACtC;EACA;EACA;EACA;EACA,IAAIC,MAAM,CAACE,MAAM,GAAG,CAAC,IACjB,EAAEF,MAAM,CAACA,MAAM,CAACE,MAAM,GAAG,CAAC,CAAC,KAAKR,GAAG,CAACS,OAAO,IAAIH,MAAM,CAAC,CAAC,CAAC,KAAKN,GAAG,CAACU,uBAAuB,CAAC,EAAE;IAC3F,OAAO,KAAK;EAChB;EACA,IAAIC,MAAM,GAAGV,WAAW,CAACW,SAAS,CAACN,MAAM,CAAC,CAAC,CAAC,CAAC;EAC7C,IAAIO,MAAM,GAAGZ,WAAW,CAACW,SAAS,CAACN,MAAM,CAAC,CAAC,CAAC,CAAC;EAC7C,IAAI,CAACK,MAAM,CAACG,OAAO,CAAC,CAAC,IAAI,CAACD,MAAM,CAACC,OAAO,CAAC,CAAC,EAAE;IACxC,OAAO,KAAK;EAChB;EACA;EACA,OAAO,IAAI;AACf;AACAV,KAAK,CAACW,MAAM,GAAG,YAAY;EAAE,OAAO,0BAA0B;AAAE,CAAC;AACjE,SAASC,MAAMA,CAACC,CAAC,EAAEC,OAAO,EAAE;EACxBnB,SAAS,CAAC;IACNkB,CAAC,EAAEnB,KAAK,CAACqB,MAAM;IACfD,OAAO,EAAE,CAACtB,OAAO,CAACwB,iBAAiB;EACvC,CAAC,EAAE;IACCH,CAAC,EAAEA,CAAC;IACJC,OAAO,EAAEA;EACb,CAAC,CAAC;EACF,IAAIG,CAAC,GAAGH,OAAO,CAACV,MAAM;EACtB,IAAIa,CAAC,GAAGJ,CAAC,EACL,MAAM,IAAIK,SAAS,CAAC,6BAA6B,CAAC;EACtD,OAAO1B,OAAO,CAAC2B,OAAO,CAAC,EAAE,CAACC,MAAM,CAACtB,WAAW,GAAGe,CAAC,EAAEC,OAAO,EAAEhB,WAAW,GAAGmB,CAAC,EAAErB,GAAG,CAACyB,gBAAgB,CAAC,CAAC;AACtG;AACA,SAASC,MAAMA,CAACC,MAAM,EAAEC,eAAe,EAAE;EACrC,IAAItB,MAAM,GAAGV,OAAO,CAACW,SAAS,CAACoB,MAAM,CAAC;EACtC5B,SAAS,CAACK,KAAK,EAAEE,MAAM,EAAEsB,eAAe,CAAC;EACzC,OAAO;IACHX,CAAC,EAAEX,MAAM,CAAC,CAAC,CAAC,GAAGJ,WAAW;IAC1BgB,OAAO,EAAEZ,MAAM,CAACuB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;EAC/B,CAAC;AACL;AACAC,MAAM,CAACC,OAAO,GAAG;EACb3B,KAAK,EAAEA,KAAK;EACZsB,MAAM,EAAEA,MAAM;EACdV,MAAM,EAAEA;AACZ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script"}