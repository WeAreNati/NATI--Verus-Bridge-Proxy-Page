{"ast":null,"code":"import{isETHAddress,isiAddress,isRAddress}from\"./rules\";import{GLOBAL_ADDRESS,BLOCKCHAIN_NAME,FLAGS}from'constants/contractAddress';export const getTokenOptions=(poolAvailable,tokens)=>poolAvailable?tokens:tokens.filter(option=>!(parseInt(option.flags)&FLAGS.MAPPING_ISBRIDGE_CURRENCY));export const getDestinations=(token,addr)=>[{value:BLOCKCHAIN_NAME,label:\"\".concat(token!==null&&token!==void 0?token:BLOCKCHAIN_NAME,\" on \").concat(BLOCKCHAIN_NAME),iaddress:addr},{value:\"bridgeBRIDGE\",label:\"Convert to Bridge.vETH on \".concat(BLOCKCHAIN_NAME),iaddress:GLOBAL_ADDRESS.BETH},{value:\"bridgeDAI\",label:\"Convert to DAI on \".concat(BLOCKCHAIN_NAME),iaddress:GLOBAL_ADDRESS.DAI},{value:\"bridgeVRSC\",label:\"Convert to \".concat(BLOCKCHAIN_NAME,\" on \").concat(BLOCKCHAIN_NAME),iaddress:GLOBAL_ADDRESS.VRSC},{value:\"bridgeETH\",label:\"Convert to ETH on \".concat(BLOCKCHAIN_NAME),iaddress:GLOBAL_ADDRESS.ETH},{value:\"bridgeMKR\",label:\"Convert to MKR on \".concat(BLOCKCHAIN_NAME),iaddress:GLOBAL_ADDRESS.MKR},{value:\"swaptoBRIDGE\",label:\"Convert to Bridge.vETH Token and (Bounce back to ETH)\",iaddress:GLOBAL_ADDRESS.BETH},{value:\"swaptoVRSC\",label:\"Convert to \".concat(BLOCKCHAIN_NAME,\" Token and (Bounce back to ETH)\"),iaddress:GLOBAL_ADDRESS.VRSC},{value:\"swaptoDAI\",label:\"Convert to DAI Token and (Bounce back to ETH)\",iaddress:GLOBAL_ADDRESS.DAI},{value:\"swaptoETH\",label:\"Convert to ETH and (Bounce back to ETH)\",iaddress:GLOBAL_ADDRESS.ETH},{value:\"swaptoMKR\",label:\"Convert to MKR Token and (Bounce back to ETH)\",iaddress:GLOBAL_ADDRESS.MKR}];const destionationOptionsByPool=[\"swaptoBRIDGE\",\"swaptoVRSC\",'bridgeBRIDGE','swaptoDAI','swaptoETH',\"swaptoMKR\"];export const getDestinationOptions=(poolAvailable,address,selectedToken,tokenName)=>{// Destination currency is vrsc all curencies pre pool launch.\nif(!address||!selectedToken){return[];}const options=!poolAvailable?[{value:BLOCKCHAIN_NAME,label:\"\".concat(tokenName!==null&&tokenName!==void 0?tokenName:BLOCKCHAIN_NAME,\" on \").concat(BLOCKCHAIN_NAME),iaddress:selectedToken}]:getDestinations(tokenName,selectedToken);const addedToken=![GLOBAL_ADDRESS.DAI,GLOBAL_ADDRESS.VRSC,GLOBAL_ADDRESS.BETH,GLOBAL_ADDRESS.ETH,GLOBAL_ADDRESS.MKR].includes(selectedToken);if(isETHAddress(address)){const ethOptions=options.filter(option=>![BLOCKCHAIN_NAME,'bridgeBRIDGE','bridgeDAI','bridgeVRSC','bridgeETH','bridgeMKR',\"bridge\".concat(BLOCKCHAIN_NAME)].includes(option.value));if(addedToken){return[];//if its a mapped added token dont offer bounce back\n}if(selectedToken){return ethOptions.filter(option=>option.iaddress!==selectedToken);}else{return ethOptions;}}else if(isiAddress(address)||isRAddress(address)){const vscOptions=options.filter(option=>[BLOCKCHAIN_NAME,'bridgeBRIDGE','bridgeDAI','bridgeVRSC','bridgeETH','bridgeMKR'].includes(option.value));if(!poolAvailable||addedToken){return vscOptions.filter(option=>option.value===BLOCKCHAIN_NAME);}else{return vscOptions.filter(option=>option.iaddress!==selectedToken||option.value.slice(0,6)!=='bridge');}}else{return options;}};","map":{"version":3,"names":["isETHAddress","isiAddress","isRAddress","GLOBAL_ADDRESS","BLOCKCHAIN_NAME","FLAGS","getTokenOptions","poolAvailable","tokens","filter","option","parseInt","flags","MAPPING_ISBRIDGE_CURRENCY","getDestinations","token","addr","value","label","concat","iaddress","BETH","DAI","VRSC","ETH","MKR","destionationOptionsByPool","getDestinationOptions","address","selectedToken","tokenName","options","addedToken","includes","ethOptions","vscOptions","slice"],"sources":["/Users/oddfl3x/Code/varB/vARRRBridgeWebsite-main/src/utils/options.js"],"sourcesContent":["import { isETHAddress, isiAddress, isRAddress } from \"./rules\";\nimport { GLOBAL_ADDRESS, BLOCKCHAIN_NAME, FLAGS } from 'constants/contractAddress';\n\nexport const getTokenOptions = (poolAvailable, tokens) => (\n  poolAvailable ? tokens : tokens.filter(option => !(parseInt(option.flags) & FLAGS.MAPPING_ISBRIDGE_CURRENCY))\n)\n\nexport const getDestinations = (token, addr) => ([\n  { value: BLOCKCHAIN_NAME, label: `${token ?? BLOCKCHAIN_NAME} on ${BLOCKCHAIN_NAME}`, iaddress: addr },\n  { value: \"bridgeBRIDGE\", label: `Convert to Bridge.vETH on ${BLOCKCHAIN_NAME}`, iaddress: GLOBAL_ADDRESS.BETH },\n  { value: \"bridgeDAI\", label: `Convert to DAI on ${BLOCKCHAIN_NAME}`, iaddress: GLOBAL_ADDRESS.DAI },\n  { value: \"bridgeVRSC\", label: `Convert to ${BLOCKCHAIN_NAME} on ${BLOCKCHAIN_NAME}`, iaddress: GLOBAL_ADDRESS.VRSC },\n  { value: \"bridgeETH\", label: `Convert to ETH on ${BLOCKCHAIN_NAME}`, iaddress: GLOBAL_ADDRESS.ETH },\n  { value: \"bridgeMKR\", label: `Convert to MKR on ${BLOCKCHAIN_NAME}`, iaddress: GLOBAL_ADDRESS.MKR },\n  { value: \"swaptoBRIDGE\", label: \"Convert to Bridge.vETH Token and (Bounce back to ETH)\", iaddress: GLOBAL_ADDRESS.BETH },\n  { value: \"swaptoVRSC\", label: `Convert to ${BLOCKCHAIN_NAME} Token and (Bounce back to ETH)`, iaddress: GLOBAL_ADDRESS.VRSC },\n  { value: \"swaptoDAI\", label: \"Convert to DAI Token and (Bounce back to ETH)\", iaddress: GLOBAL_ADDRESS.DAI },\n  { value: \"swaptoETH\", label: \"Convert to ETH and (Bounce back to ETH)\", iaddress: GLOBAL_ADDRESS.ETH },\n  { value: \"swaptoMKR\", label: \"Convert to MKR Token and (Bounce back to ETH)\", iaddress: GLOBAL_ADDRESS.MKR }\n]);\n\nconst destionationOptionsByPool = [\n  \"swaptoBRIDGE\", \"swaptoVRSC\", 'bridgeBRIDGE', 'swaptoDAI', 'swaptoETH', \"swaptoMKR\"\n]\n\nexport const getDestinationOptions = (poolAvailable, address, selectedToken, tokenName) => {\n\n  // Destination currency is vrsc all curencies pre pool launch.\n  if (!address || !selectedToken) {\n    return [];\n  }\n  const options = !poolAvailable\n    ? [{ value: BLOCKCHAIN_NAME, label: `${tokenName ?? BLOCKCHAIN_NAME} on ${BLOCKCHAIN_NAME}`, iaddress: selectedToken }]\n    : getDestinations(tokenName, selectedToken)\n\n  const addedToken = ![GLOBAL_ADDRESS.DAI, GLOBAL_ADDRESS.VRSC, GLOBAL_ADDRESS.BETH, GLOBAL_ADDRESS.ETH, GLOBAL_ADDRESS.MKR].includes(selectedToken);\n\n  if (isETHAddress(address)) {\n    const ethOptions = options.filter(option => ![BLOCKCHAIN_NAME, 'bridgeBRIDGE', 'bridgeDAI', 'bridgeVRSC', 'bridgeETH', 'bridgeMKR', `bridge${BLOCKCHAIN_NAME}`].includes(option.value));\n    if (addedToken) {\n      return [] //if its a mapped added token dont offer bounce back\n    }\n    if (selectedToken) {\n      return ethOptions.filter(option => option.iaddress !== selectedToken);\n    }\n    else {\n      return ethOptions\n    }\n  }\n  else if (isiAddress(address) || isRAddress(address)) {\n    const vscOptions = options.filter(option => [BLOCKCHAIN_NAME, 'bridgeBRIDGE', 'bridgeDAI', 'bridgeVRSC', 'bridgeETH', 'bridgeMKR'].includes(option.value));\n\n    if (!poolAvailable || addedToken) {\n      return vscOptions.filter(option => option.value === BLOCKCHAIN_NAME)\n    }\n\n    else {\n      return vscOptions.filter(option => (option.iaddress !== selectedToken) || (option.value.slice(0, 6) !== 'bridge'));\n    }\n  }\n  else {\n    return options;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}