{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VdxfUniValue = exports.VDXF_UNI_VALUE_VERSION_CURRENT = exports.VDXF_UNI_VALUE_VERSION_INVALID = void 0;\nconst varuint_1 = require(\"../utils/varuint\");\nconst bufferutils_1 = require(\"../utils/bufferutils\");\nconst address_1 = require(\"../utils/address\");\nconst vdxf_1 = require(\"../constants/vdxf\");\nconst bn_js_1 = require(\"bn.js\");\nconst vdxf_2 = require(\"../vdxf\");\nconst varint_1 = require(\"../utils/varint\");\nexports.VDXF_UNI_VALUE_VERSION_INVALID = new bn_js_1.BN(0, 10);\nexports.VDXF_UNI_VALUE_VERSION_CURRENT = new bn_js_1.BN(1, 10);\nconst {\n  BufferWriter,\n  BufferReader\n} = bufferutils_1.default;\n// This UniValue class was adapted from C++ code for encoding JSON objects into bytes. It is not serialization and\n// therefore doesn't have a fromBuffer function, as you can't reliably decode it, only encode.\nclass VdxfUniValue {\n  constructor(data) {\n    if (data === null || data === void 0 ? void 0 : data.values) this.values = data.values;\n    if (data === null || data === void 0 ? void 0 : data.version) this.version = data.version;else this.version = exports.VDXF_UNI_VALUE_VERSION_CURRENT;\n  }\n  getByteLength() {\n    let length = 0;\n    for (const key of this.values.keys()) {\n      const value = this.values.get(key);\n      length += vdxf_1.HASH160_BYTE_LENGTH;\n      length += varint_1.default.encodingLength(this.version);\n      if (key == vdxf_2.DATA_TYPE_STRING.vdxfid) {\n        const valueString = value;\n        const valBuf = Buffer.from(valueString, 'utf8');\n        //NOTE 3 is from ss type + ver + vdxfidver \n        length += varint_1.default.encodingLength(new bn_js_1.BN(valBuf.length + 3));\n        length += varuint_1.default.encodingLength(valBuf.length);\n        length += valBuf.length;\n      } else throw new Error(\"Invalid or unrecognized vdxf key for object type\");\n    }\n    return length;\n  }\n  toBuffer() {\n    const writer = new BufferWriter(Buffer.alloc(this.getByteLength()));\n    for (const key of this.values.keys()) {\n      const value = this.values.get(key);\n      writer.writeSlice((0, address_1.fromBase58Check)(key).hash);\n      writer.writeVarInt(this.version);\n      if (key == vdxf_2.DATA_TYPE_STRING.vdxfid) {\n        const valueString = value;\n        const valBuf = Buffer.from(valueString, 'utf8');\n        //NOTE 3 is from ss type + ver + vdxfidver \n        writer.writeVarInt(new bn_js_1.BN(valBuf.length + 3));\n        writer.writeVarSlice(valBuf);\n      } else throw new Error(\"Invalid or unrecognized vdxf key for object type\");\n    }\n    return writer.buffer;\n  }\n  fromBuffer(buffer, offset = 0, keylist = []) {\n    const reader = new BufferReader(buffer, offset);\n    let lastPrereadOffset = reader.offset;\n    function readNextKey() {\n      lastPrereadOffset = reader.offset;\n      try {\n        return (0, address_1.toBase58Check)(reader.readSlice(20), vdxf_1.I_ADDR_VERSION);\n      } catch (e) {\n        return null;\n      }\n    }\n    this.values = new Map();\n    for (const key of keylist) {\n      const dataTypeKey = readNextKey();\n      this.version = reader.readVarInt();\n      if (this.version.gt(exports.VDXF_UNI_VALUE_VERSION_CURRENT)) throw new Error(\"Unknown VDXFUniValue version\");\n      if (dataTypeKey == vdxf_2.DATA_TYPE_STRING.vdxfid) {\n        reader.readVarInt();\n        const slice = reader.readVarSlice();\n        this.values.set(dataTypeKey, slice.toString('utf8'));\n      } else {\n        throw new Error(\"Invalid or unrecognized vdxf key for object type\");\n      }\n    }\n    return reader.offset;\n  }\n  static fromJson(obj) {\n    const map = new Map();\n    for (const key in obj) {\n      map.set(key, obj[key]);\n    }\n    return new VdxfUniValue({\n      values: map\n    });\n  }\n  toJson() {\n    const ret = {};\n    for (const key of this.values.keys()) {\n      ret[key] = this.values.get(key);\n    }\n    return ret;\n  }\n}\nexports.VdxfUniValue = VdxfUniValue;","map":{"version":3,"names":["Object","defineProperty","exports","value","VdxfUniValue","VDXF_UNI_VALUE_VERSION_CURRENT","VDXF_UNI_VALUE_VERSION_INVALID","varuint_1","require","bufferutils_1","address_1","vdxf_1","bn_js_1","vdxf_2","varint_1","BN","BufferWriter","BufferReader","default","constructor","data","values","version","getByteLength","length","key","keys","get","HASH160_BYTE_LENGTH","encodingLength","DATA_TYPE_STRING","vdxfid","valueString","valBuf","Buffer","from","Error","toBuffer","writer","alloc","writeSlice","fromBase58Check","hash","writeVarInt","writeVarSlice","buffer","fromBuffer","offset","keylist","reader","lastPrereadOffset","readNextKey","toBase58Check","readSlice","I_ADDR_VERSION","e","Map","dataTypeKey","readVarInt","gt","slice","readVarSlice","set","toString","fromJson","obj","map","toJson","ret"],"sources":["/Users/oddfl3x/Code/varB/vARRRBridgeWebsite-main/node_modules/verus-typescript-primitives/dist/pbaas/VdxfUniValue.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.VdxfUniValue = exports.VDXF_UNI_VALUE_VERSION_CURRENT = exports.VDXF_UNI_VALUE_VERSION_INVALID = void 0;\nconst varuint_1 = require(\"../utils/varuint\");\nconst bufferutils_1 = require(\"../utils/bufferutils\");\nconst address_1 = require(\"../utils/address\");\nconst vdxf_1 = require(\"../constants/vdxf\");\nconst bn_js_1 = require(\"bn.js\");\nconst vdxf_2 = require(\"../vdxf\");\nconst varint_1 = require(\"../utils/varint\");\nexports.VDXF_UNI_VALUE_VERSION_INVALID = new bn_js_1.BN(0, 10);\nexports.VDXF_UNI_VALUE_VERSION_CURRENT = new bn_js_1.BN(1, 10);\nconst { BufferWriter, BufferReader } = bufferutils_1.default;\n// This UniValue class was adapted from C++ code for encoding JSON objects into bytes. It is not serialization and\n// therefore doesn't have a fromBuffer function, as you can't reliably decode it, only encode.\nclass VdxfUniValue {\n    constructor(data) {\n        if (data === null || data === void 0 ? void 0 : data.values)\n            this.values = data.values;\n        if (data === null || data === void 0 ? void 0 : data.version)\n            this.version = data.version;\n        else\n            this.version = exports.VDXF_UNI_VALUE_VERSION_CURRENT;\n    }\n    getByteLength() {\n        let length = 0;\n        for (const key of this.values.keys()) {\n            const value = this.values.get(key);\n            length += vdxf_1.HASH160_BYTE_LENGTH;\n            length += varint_1.default.encodingLength(this.version);\n            if (key == vdxf_2.DATA_TYPE_STRING.vdxfid) {\n                const valueString = value;\n                const valBuf = Buffer.from(valueString, 'utf8');\n                //NOTE 3 is from ss type + ver + vdxfidver \n                length += varint_1.default.encodingLength(new bn_js_1.BN(valBuf.length + 3));\n                length += varuint_1.default.encodingLength(valBuf.length);\n                length += valBuf.length;\n            }\n            else\n                throw new Error(\"Invalid or unrecognized vdxf key for object type\");\n        }\n        return length;\n    }\n    toBuffer() {\n        const writer = new BufferWriter(Buffer.alloc(this.getByteLength()));\n        for (const key of this.values.keys()) {\n            const value = this.values.get(key);\n            writer.writeSlice((0, address_1.fromBase58Check)(key).hash);\n            writer.writeVarInt(this.version);\n            if (key == vdxf_2.DATA_TYPE_STRING.vdxfid) {\n                const valueString = value;\n                const valBuf = Buffer.from(valueString, 'utf8');\n                //NOTE 3 is from ss type + ver + vdxfidver \n                writer.writeVarInt(new bn_js_1.BN(valBuf.length + 3));\n                writer.writeVarSlice(valBuf);\n            }\n            else\n                throw new Error(\"Invalid or unrecognized vdxf key for object type\");\n        }\n        return writer.buffer;\n    }\n    fromBuffer(buffer, offset = 0, keylist = []) {\n        const reader = new BufferReader(buffer, offset);\n        let lastPrereadOffset = reader.offset;\n        function readNextKey() {\n            lastPrereadOffset = reader.offset;\n            try {\n                return (0, address_1.toBase58Check)(reader.readSlice(20), vdxf_1.I_ADDR_VERSION);\n            }\n            catch (e) {\n                return null;\n            }\n        }\n        this.values = new Map();\n        for (const key of keylist) {\n            const dataTypeKey = readNextKey();\n            this.version = reader.readVarInt();\n            if (this.version.gt(exports.VDXF_UNI_VALUE_VERSION_CURRENT))\n                throw new Error(\"Unknown VDXFUniValue version\");\n            if (dataTypeKey == vdxf_2.DATA_TYPE_STRING.vdxfid) {\n                reader.readVarInt();\n                const slice = reader.readVarSlice();\n                this.values.set(dataTypeKey, slice.toString('utf8'));\n            }\n            else {\n                throw new Error(\"Invalid or unrecognized vdxf key for object type\");\n            }\n        }\n        return reader.offset;\n    }\n    static fromJson(obj) {\n        const map = new Map();\n        for (const key in obj) {\n            map.set(key, obj[key]);\n        }\n        return new VdxfUniValue({\n            values: map\n        });\n    }\n    toJson() {\n        const ret = {};\n        for (const key of this.values.keys()) {\n            ret[key] = this.values.get(key);\n        }\n        return ret;\n    }\n}\nexports.VdxfUniValue = VdxfUniValue;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}